        SECCION 18 QUASAR

La idea de Quasar es tener un montón de componentes ya estilizados.También tiene una API para rehacerlos.En esta sección aprenderemos los principales conceptos relacionados a Quasar, un framework basado en Vue.js que permite un desarrollo rápido gracias a un repertorio completo de componentes previamente estilizados.

                VIDEO 303 CREANDO UN PROYECTO CON QUASAR

Docu: https://quasar.dev/
Quasar es un framework basado en Vue que sirve para crear aplicaciones web/de escritorio,etc.Hay varias formas de crear un proyecto con Quasar pero vamos a instalar de forma global su cli:
>yarn global add @quasar/cli | npm i -g @quasar/cli

Puedo comprobar con quasar --version si se hizo la instalación correctamente
Despues creamos el proyecto con 'yarn create quasar' y ojo,para levantar el proyecto es con 'quasar dev'.

                VIDEO 304 EXPLICACION DE LOS ARCHIVOS DE UN PROYECTO CON QUASAR

El primer directorio es el '.quasar'.No hay que tocar ninguno de los js que tiene dentro(ya lo pone que no hay que editar).Son archivos autogenerados cada vez que haga un build o un start,asi que no tiene sentido tocarlos ya que se autogeneraran de nuevo.Deben ser ignorados en el .gitignore
El segundo directorio es el '.vscode'.De nuevo no hace falta tocar nada
El tercer directorio es el node_modules.Su nombre lo dice todo.Aqui se encuentran todos los modulos necesarios para el desarrollo,compilacion,despliegue y testeo de la aplicación
El siguiente directorio,la carpeta public es una zona donde puedo dejar recursos que no quiera que sean compilados o manipulados y me van a servir en esa aplicación(imagenes,videos,iconos,svgs...)
El src lo dejamos para el siguiente video.
El archivo .editorconfig son configuraciones del editor
Despues viene el .eslintignore para definir archivos que ignore el linter y el .eslintrc.js para configurar ese linter
El .gitignore para ignorar archivos a subir a GitHub
El .postcssrc.js es otro archivo de configuracion para el compilador de css
El babel.config.js de nuevo configurará el Babel
El jsconfig.json permite configurar cosas como poner alias a los paths(fijate que viene con unos cuantos)
En el package.json se encuentran las dependencias que está usando el proyecto,asi como los scripts y otras configuraciones del proyecto.Fijate que no ha venido con un comando para arrancar la app,pero sabiendo que arranca con quasar dev podemos crearlo ya("start":"quasar dev")
El archivo quasar.config.js permite realizar modificaciones del framework.Se usa bastante
El README.md permite documentar la app y el yarn.lock o package-lock para ahondar en las dependencias del proyecto.Quasar recomienda NO ignorarlo.Jamás se deberia modificar este archivo manualmente.

                VIDEO 305 EXPLICACION DEL DIRECTORIO SRC EN UNA APP DE QUASAR

NOTA: Vuex ha dejado de tener soporte,ahora mismo está deprecated solo,asi que podemos usarlo aún.Se recomienda Pina como gestor de estado.

En src/assets tenemos assets que pueden ser modificados(a diferencia de la carpeta public) en la compilación o despliegue.También puede ser que el framework(o quasar,o webpack,next,etc) termine añadiendo un hash al nombre del estático para prevenir el cacheo.En resumen,se pueden modificar

El directorio src/boot es tipico de una app de Quasar.De momento tiene un axios.js con una configuracion global de axios,aunque viene a medias y habrá que configurarla bien

La carpeta src/components viene con un componente.Se recomienda que modularizemos la app,asi que este directorio deberia moverlo en una app real.Fijate que las tags son <q-item></q-item> o <q-item-section></q-item-section> ya que estamos en Quasar.
NOTA: en Vue se puede hacer como en React y :caption="true" podemos simplificarlo como caption.Asi pues,en <q-item-label caption></q-item-label> debo interpretar ese caption como un boolean a true.
Fijate tmb que están usando defineComponente en vez de defineAsyncComponent

La carpeta src/css viene con estilos ya establecidos para el starter.En el archivo app.css debo configurar cualquier estilo global,ya que lo está importando el App.vue,que es el punto de entrada de la app.

El directorio src/layouts permite definir cascarones(herencia entre Html).En este archivo Quasar está exponiendo un objeto global llamado $q donde puedo consultar muchas cosas(como la version de Electron,medidas de la ventana,etc)

El directorio src/pages permite construir las paginas/rutas de la app.La pagina para el Index la puedo tomar de plantilla para crear las sucesivas paginas de la app(fijate en el <q-page></q-page>)

El directorio src/router permite declarar las rutas de la app.Fijate que parece bastante bueno el sistema de rutas de Quasar:
const routes = [
  {
    path: '/',
    component: () => import('layouts/MainLayout.vue'),
    children: [
      { path: '', component: () => import('pages/IndexPage.vue') }
    ]
  },
  {
    path: '/:catchAll(.*)*',
    component: () => import('pages/ErrorNotFound.vue')
  }
]

export default routes
En el src/router/index.js está configurado el modo de rutas(createMemoryRouter),etc.
En el src/store tengo un modulo de ejemplo con el state,actions,etc y un archivo index.js con un store global semi-configurado,que NO deberia usar pues deberia usar stores modularizados(slices).Fijate que me dejan un cascaron que puedo ir copiando y pegando,es lo mismo que hicimos en la seccion correspondiente
Por último en esta zona hay un file en src/store llamado store-flag.d.ts para definiciones de typescript.Supongo que del store.


Despues tenemos el App.vue es el punto de entrada de la app (src/App.vue).Solo tiene el router-view:
Y a la misma altura tenemos el src/index.template.html para poder integrar CDNS o realizar otras configuraciones al html.Es el html que se tomará como base para el index.html resultante de hacer el build de la aplicación.Genial todo.

<template>
  <router-view />
</template>

<script>
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'App'
})
</script>

                VIDEO 306 CAMBIAR LA ICONOGRAFIA DE LA APLICACION


Docu: https://quasar.dev/options/installing-icon-libraries
Honestamente los iconos de font-awesome del starter se sienten viejos ya.Quasar da soporte por defecto ya a varias librerias(Material icons, Bootstrap Icons, Font Awesome).Son iconos vectorizados ya listos para ser usados

Simplemente hay que ir al archivo quasar.config.js y añadir la lib en extras:
-> extras: ["material-icons"]
En nuestro caso realmente no queremos la de material-icons,sino la de line-icons

Ya no se llamarán de la misma forma:

const linksList = [
  {
    title: 'Docs',
    caption: 'quasar.dev',
    icon: 'school', <- "las la-school" etc
    link: 'https://quasar.dev'
  },
  {
    title: 'Github',
    caption: 'github.com/quasarframework',
    icon: 'code',
    link: 'https://github.com/quasarframework'
  },


                VIDEO 307 CREAR PAGINAS Y RUTAS EN QUASAR

Simplemente creamos en el folder pages las paginas(realmente esto es una convención,lo importante es la definicion de las rutas):
<template>
  <q-page class="flex">
    <h1>Flex</h1>
  </q-page>
</template>

<script>
import { defineComponent } from "vue";

export default defineComponent({
  name: "FlexPage",
});
</script>

Y simplemente declaro una ruta para el import de ese componente:
const routes = [
  {
    path: "/",
    component: () => import("layouts/MainLayout.vue"),
    children: [
      { path: "", component: () => import("pages/IndexPage.vue") },
      { path: "typography", name: "typography", component: () => import("pages/Typography.vue"), },
      { path: "flex", name: "flex", component: () => import("pages/Flex.vue") },
    ],
  },

  Sin embargo fijate que no va bien la navegación por el '#' que esta en cada ruta.Hay que usar otro tipo de navegación.

  VIDEO 308 USANDO LA NAVEGACION DINAMICA EN QUASASR

NOTA: Vue tiene algo muy parecido a mandar todas las props en React(props => <Component {...props}) pero aqui es con un v-bind="object-to-send".Ejemplo:

<EssentialLink
  v-for="link in essentialLinks"
  :key="link.title"
  v-bind="link" <- le mandamos todo el link

Dado que el link era un objeto que luce asi:
{
  title:string,
  caption:string,
  icon:string,
  link:string
}
Podemos ver que estamos mandando 4 propiedades(ojo que es como un {...props,estamos esparciendo las props})
Asi pues llegarán 4 properties al componente que podemos rescatar:
  props: {
    title: {
      type: String,
      required: true
    },

    caption: {
      type: String,
      default: ''
    },

    link: {
      type: String,
      default: '#'
    },

    icon: {
      type: String,
      default: ''
    }
  },  

IMPORTANTE: en el composition API en el método setup tengo un primer argumento opcional que recibe las props:
setup(props){
  console.log(props)
}

NOTA: fijate que en la impresion por consola veo que hay un Handler y un Target.Recuerda que esto simplemente significa que es un objeto reactivo controlado por el framework.Fijate tmb que no puedo desestructurar ese argumento ya que perderia esta reactividad

Bien,ya sabiendo esto simplemente tenemos que cambiar el 
  <q-item
    clickable
    tag="a"
    @click="navigateTo"
  >
y agregarle esa funcion que navegará a props.link si es una ruta interna o a una ruta externa si el link empieza por http:
  setup(props){
    const router = useRouter();    

    return {
      navigateTo(){
        if(props.link.startsWith('http')){
          window.open(props.link,'_blank')
        }else{
          router.push({name: props.link})
        }
      }
    }
  }
Interesante

      VIDEO 309 CAMBIAR TYPOGRAPHY

Docu: https://quasar.dev/style/typography
Quasar ya ofrece su tipografia.Tan solo es usar sus clases como text-h1 o text-subtitle2.Obviamente cubren casi todo como el tamaño de la fuente,la alineacion(text-left),estilo(text-uppercase) o peso de la fuente(text-weight-thin):

 <q-page class="flex column q-pa-md">
    <span class="text-h1 text-weight-thin">Headline 1</span>
    <span class="text-h2">Headline 2</span>
    <span class="text-h3">Headline 3</span>
    <span class="text-h4 text-weight-medium">Headline 4</span>
    <span class="text-h5">Headline 5</span>
    <span class="text-h6 text-weight-bold">Headline 6</span>

    <q-separator class="q-my-sm" />
    <span class="text-subtitle1"> Subtitle 1</span>
    <span class="text-subtitle2">Subtitle 2</span>

Tambiñén se pueden añadir fuentes externas al proyecto,podemos usar cualquiera

    VIDEO 310 REFACTORIZAR ENLACES A  OTRO ARCHIVO 

Siempre hay que usar buenas prácticas.La definicion de las rutas deberia estar en su archivo propio.Simplemente sacamos ese array del componente MainLayout ya que no pinta nada hay.
Por el mismo motivo este layout tampoco tendria que tener la lógica de abrir el drawer.De echo la vamos a sacar al store

    VIDEO 311 CONTROLAR EL DRAWER DESDE VUEX

 Aparte del store vamos a crear un hook tmb para controlar este Sidebar para asi aprender más.De esta forma cada vez que un componente quiera abrir el menu solo tendrá que llamar al hook.

Asi pues nos creamos un initialState de momento asi:
export default function(){
  return {
   isSideMenuOpen: true, 
  }
}
y una mutation y un getter.Recuerda que ambos reciben el state como primer argumento y además es el state del modulo en el que estén:

export function toggleSideMenu (state) {
  return (state.isSideMenuOpen = !state.isSideMenuOpen);
}

Ya solo queda llamar al getter y la mutation.Recuerda que el getter tiene que ser a traves de la funcion computed que recibe otra funcion por argumento mientras que la mutation es una simple funcion:

  setup() {
    const store = useStore();

    return {
      sideMenuOpen: computed(() => store.getters['ui/getSideMenuOpen']),
      toogleSideMenu: () => store.commit('ui/toggleSideMenu'), 
      linksList,
    };
En este punto puedo ver que realmente esto no queda reutilizable.Si ahora otro componente quisiera abrir/cerrar el Sidebar tendria que volver a importar el composable function useStore,la funcion computed y volver a definir todo.Obviamente mejor creamos un hook
Fijate tmb que de nuevo esté código no deberia estar atado al main layout,asi que el hook viene perfecto

      VIDEO 311 USEUI - COMPOSABLE FUNCTION

Simplemente hacemos un hook con lo que ya teniamos:

export const useUI = () => {
   const store = useStore();

   return {
     sideMenuOpen: computed(() => store.getters["ui/getSideMenuOpen"]),
     toogleSideMenu: () => store.commit("ui/toggleSideMenu"),
   };
}

En este punto solo hay que llamar al hook desde el componente que queramos:

<q-btn 
  color="primary"
  class="q-mt-md"
  label="Open Sidebar"
  @click="toogleSideMenu" />
  </q-page>
</template>

<script>
import { useUI } from "../composables/useUi";
import { defineComponent } from "vue";

export default defineComponent({
  name: "TypographyPage",
  setup() {
    const { toogleSideMenu } = useUI();
    return {
      toogleSideMenu,
    };
  },
});
</script>

Fijate que el método setup va dentro del export default defineComponent

    VIDEO 313 PROPIEDADES COMPUTADAS SET Y GET

Si ponemos el ancho de pantalla en M podemos ver que la App está intentando cambiar el valor de la propiedad 'sideMenuOpen',pero es una propiedad computada de solo lectura.

Concretamente lo está haciendo el componente drawer:
  <q-drawer v-model="sideMenuOpen" show-if-above bordered>

IMPORTANTE: esta sintaxis solo expone el getter:
sideMenuOpen: computed(() => store.getters["ui/getSideMenuOpen"]),

pero perfectamente podemos exponer el getter y el setter a la propiedad computada usando esta sintaxis:
 computed({
      get(){ return xx},
      set(val){}
    }),
Ojo,el getter siempre tiene que retornar algo y el setter tiene acceso al valor en el primer argumento.Fijate que computed() ya no retorna una funcion sino un objeto,el cual tengo que desarrollar los métodos set y get:

export const useUI = () => {
  const store = useStore();
  return{
    sideMenuOpen: computed({
      get(){ return store.getters["ui/getSideMenuOpen]},
      set(val){ store.commit('ui/toogleSideMenu)}
    })
  }
}
La mutation que tenemos es justo lo que tiene que hacer el set asi que nos vale

    VIDEO 314 SISTEMA DE FILAS Y COLUMNAS EN QUASAR

En este punto siempre hay que tener la docu a mano (https://quasar.dev/layout/grid/introduction-to-flexbox). Fijate que Quasar hace wrap por defecto y hay que especificar que no lo queremos,al contrario de CSS.También se basa en una Grid de 12 columnas.

NOTA: fijate que tengo un archivo quasar.variables.scss en la carpeta css con colores/variables por defecto sobre las que tengo vision en un proyecto de quasar(por ejemplo bg-primary hará referencia a la variable $primary de este file).Parece que ya no exponen este file,pero siguen estando las variables con el mismo nombre

IMPORTANTE: declaro una row con la clase 'row' y una columna con la clase 'col'.Si no declaro un width(col-4 | col-6,por ejemplo) a la columna se ponen en auto y los anchos son equitativos

<!-- si no le doy medida a las columnas las pondrá en col-auto -->
    <div class="row q-mb-md">
      <div class="col bg-primary">Col 1</div>
      <div class="col bg-secondary">Col 2</div>
      <div class="col bg-accent">Col 3</div>
    </div>
    <!-- por defecto una row tiene 12 columnas,si pongo dos de col-6 desaparecerá la tercera -->
    <div class="row q-mb-md">
      <div class="col bg-primary">Col 1</div>
      <div class="col col-6 bg-secondary">Col 2</div>
      <div class="col col-6 bg-accent">Col 3</div>
    </div>
    <!-- si me paso de columnas recuerda que tienen el display flex en wrap y hará salto -->
    <div class="row q-mb-md">
      <div class="col col-4 bg-primary">Col 1</div>
      <div class="col col-4 bg-secondary">Col 2</div>
      <div class="col col-6 bg-accent">Col 3</div>
    </div>
    <!-- siempre que tenga hueco en el eje X puedo alinear los items -->
    <div class="row q-mb-md justify-center">
      <div class="col col-4 bg-primary">Col 1</div>
      <div class="col col-4 bg-secondary">Col 2</div>
    </div>

      VIDEO 315 CAMBIAR COLUMNAS DEPENDIENDO DE LA RESOLUCION

Como toda app responsive llega un punto en que no sirve de nada tener 3 o 4 columnas,ya que la información no cabe hay más.Cuando sucede esto se tiene que reducir el numero de columnas y dejar que el usuario navege por la información haciendo scroll vertical(que es el comportamiento natural hoy en dia).
NOTA: tengo la extension quasar-snippets en VSCode si voy a usar Quasar a menudo

    <!-- Quasar es mobile first,debo ir ajustando contenido en base a sus breakpoints -->
    <div class="row q-mb-md justify-center">
      <div class="col col-12 col-md-6 col-lg-4 bg-primary">Col 1</div>
      <div class="col col-12 col-md-6 col-lg-4 bg-secondary">Col 2</div>
      <div class="col col-12 col-md-6 col-lg-4 bg-accent">Col 3</div>
    </div>

      VIDEO 316 INTRODUCCION A FLEXBOX

TIP: Flexbox provee una manera eficiente de maquetar,alinear y distribuir espacio entre los items de un container,incluso cuando su tamaño es desconocio o dinámico(de hay su nombre flex):

Si uso su clase row automáticamente me va a poner en flex todo,etc:

   <!-- fijate que row ya pone en flex por defecto para que sea una fila(y aparte viene en wrap todo,recuerda).Dado que quieren que sea una fila tiene todo el sentido del mundo.Por defecto estarán en justify-start-->
    <div class="row q-my-md">
      <div class="square-box bg-primary">Caja 1</div>
      <div class="square-box bg-secondary">Caja 2</div>
      <div class="square-box bg-accent">Caja 3</div>
    </div>
    <q-separator spaced />
    <!-- puedo cambiar las justificaciones del contenedor -->
    <div class="row justify-between">
      <div class="square-box bg-primary">Caja 1</div>
      <div class="square-box bg-secondary">Caja 2</div>
      <div class="square-box bg-accent">Caja 3</div>
    </div>

Si uso su clase column de nuevo me pondrá ciertos estilos:

    <!-- fijate que la clase column de nuevo trae sus estilos, trae un display flex que por ello es un bloque todo y flex direction de column(asi que si quiero alinear en el eje X tengo que usar align items center)  -->
    <div class="column bg-dark items-center">
      <div class="square-box bg-primary">Caja 1</div>
      <div class="square-box bg-secondary">Caja 2</div>
      <div class="square-box bg-accent">Caja 3</div>
    </div>

Y obviamente se pueden hacer cosas más complejas:
    <div class="column custom-height bg-warning items-center justify-between">
      <div class="square-box bg-primary self-start">Caja 1</div>
      <div class="square-box bg-secondary self-end">Caja 2</div>
      <div class="square-box bg-accent">Caja 3</div>
    </div>

La parte del Flexbox funciona bastante bien en Quasar y ayuda a colocar la información como el desarrollador quiera.

    VIDEO 317 DIALOGS Y ALERTAS

Docu: https://quasar.dev/quasar-plugins/dialog
Todos los plugins de Quasar trabajan o se usan de la misma manera.Para empezar a usar cualquier plugin hay que especificarlo en el archivo 'quasar.config' en el arreglo de plugins que hay en la propiedad framework: 

return {
  framework: {
    plugins:['Dialog']
  }
}

Y aparte de esto hay que usar el composable function que esa libreria expone y que retorna una instancia de toda la libreria parece:

import { useQuasar } from "quasar";
export default defineComponent({
  name: "DialogPage",
  setup() {
    // en $q tengo todo el objeto Quasar,el hook lo instancia y retorna
    const $q = useQuasar();
    const promptValue = ref();

 function prompt() {
      $q.dialog({
        title: "Promt",
        message: "What is your name?",
        position: "standard",
        prompt: {
          model: "",
          type: "text", // <- input type text
        },
        cancel: true,
        persistent: true,
      })
        .onOk((val) => {
          promptValue.value = val;
          console.log("OK");
        })
        .onCancel(() => {
          console.log("Cancel");
        })
        .onDismiss(() => {
          console.log("I am triggered on both OK and Cancel events");
        });
    }

    return {
      prompt,
      promptValue,
    };

Y en el html:
  <q-page class="q-pa-md">
    <span class="text-h3">Dialogs</span>
    <q-separator spaced />

    <template v-if="promptValue">
      <span class="text-h6">The value is: {{ promptValue }}</span>
      <q-separator spaced />
    </template>

    <div class="q-pa-md q-gutter-sm">
      <q-btn unelevated label="Prompt" color="primary" @click="prompt" />
    </div>
  </q-page>

  Es simplemente ver su documentación,aunque es siempre lo mismo,activar el plugin en el quasar.config y traer la instancia de quasar con el useQuasar

  NOTA: si estoy fuera de Vue puedo usar esta sintaxis:
  import { Notify } from 'quasar';
  si estoy en un archivo .vue:
  import { useQuasar } from 'quasar';

  setup(){
    const $q = useQuasar();
    $q.notify('Message')
  }
  Un composable function es considerado dentro de Vue,ojo,es como si estuviera en el setup.Fijate que esto es muy interesante.
  SOLO CUANDO ESTE EN UN ARCHIVO DE JAVASCRIPT EL CUAL NO SE EJECUTA DENTRO DEL CICLO DE VIDA DE VUE TENGO QUE USAR LA SINTAXIS PRIMERA

          VIDEO 318 INPUTS Y FORMULARIOS CON QUASAR

Docu: https://quasar.dev/vue-components/input

Quasar expone varios componentes para trabajar con formularios.Se recomienda usar su wrapper <q-form></q-form> y despues usar <q-input></q-input> y sus homólogos para textareas, radios,checkboxes,etc.
No son un plugin,no hay que especificar nada

  <div class="row justify-center">
      <div class="col-6">
        <q-form @submit="onSubmit" @reset="onReset" class="q-gutter-md">
          <q-input
            filled
            v-model="name"
            label="Enter your name"
            hint="name and surname fields"
            lazy-rules
            :rules="[(val) => (val && val.length > 0) || 'Please type something ']"
          />

          <q-input
            filled
            type="number"
            v-model="age"
            label="Enter your age"
            lazy-rules
            :rules="[
              (val) => (val !== null && val !== '') || 'Please type your age',
              (val) => (val > 0 && val < 100) || 'Please type a real age',
            ]"
          />
          <q-toogle v-model="accept" label="I accept the license and terms" />

          <div>
            <q-btn label="Submit" type="submit" color="primary" />
            <q-btn label="Reset" type="reset" color="primary" flat class="q-ml-sm" />
          </div>
        </q-form>
      </div>
    </div>

La property filled hace referencia al background gris que tiene,el v-model al model ode datos.El hint es un texto informativo del campo(no confundir con el error).Lazy rules no checkea el campo hasta que pierda el foco

TIP: Los icons de esta libreria pueden tener tres estilos(regular, solid or brand)
Para cada estilo está su clase correspondiente(lar, las o lab)

NOTA: para cambiar el icono de error del formulario en el quasar.config usar esta propiedad:
framework: {
  iconSet: 'line-awesome'
}

Otra forma es con el objeto global $q en cada archivo ya que la forma anterior no es demasiado flexible:
$q.iconSet.field.error = "las la-exclamation-triangle";
$q.iconSet.type.warning = 'mail'

IMPORTANTE fijate como puedo retornar un true o un string,ya que si es true no pasa al string.Interesante:

return (val === anotherVal) || 'Los valores no son iguales'

Por último vamos a agregar notificaciones(son un plugin)

NOTA: fijate que hemos estado usando export default defineComponent({}) y hay metemos todo.
Esta forma se usa principalmente cuando necesitas Type safety, es decir cuando necesitas tipado estricto principalmente, o ayudas de linter. En JavaScript Vue es opcional, pero en TypeScript si es obligatorio.
Como resumen parece una opcion valida para proyectos no muy grandes,aunque es totalmente opinionada en cuanto a los estilos.Seguramente no se use mucho en proyectos empresariales.Sea como sea hay tengo la docu que parece bastante buena y la opcion.

      SECCION 19 MAPAS APP VUE-WITH-TYPESCRIPT

Usaremos MapBox(es gratis hasta un cierto numero de peticiones)En esta sección quiero que aprendamos y reforcemos muchos de los temas aquí vistos en el curso y también aprendamos conceptos nuevos.

1- TypeScript con Vue
2- Mapas con Mapbox
3- Marcadores
4- Polylines
5- CompositionAPI
6- VueX + TypeScript
7- Rutas y lugares

Es una sección técnicamente complicada, no por el hecho de usar mapas o TypeScript, lo que lo hace difícil es su configuración inicial, luego todo es cuesta abajo.

            VIDEO 326 INICIO DEL PROYECTO

 
Creamos un proyecto con 'vue create project-name' (fijate que tuve que instalar con npm i -g @vue/cli).Elegimos typescript,la v3 etc.

Fijate que ahora las etiquetas script tengo que usar la propiedad lang:
<script lang="ts"></script>
Y que hay que usar export default defineComponent({}) despues(aunque esto ya lo he visto)

NOTA: si vamos al store/index.ts vemos que la implementación que hicieron de Vuex es demasiado simple(Quasar si lo hace bien,pero aqui te dan todo como en Javascript,debieron profundizar más)

IMPORTANTE: recuerda que 1000 interfaces de Typescript equivalen a 0 lineas de código de Javascript

  VIDEO 328 CONFIGURAR VUEX CON TS Y MODULO CASCARÓN REUTILIZABLE

Lo primero es crear el store con un Tipo T compuesto de los subtipos de cada state de cada modulo:

En el store/index.ts

import { createStore } from 'vuex'

import exampleModule from './module-template';
import { ExampleStateInterface} from './module-template/state';

export interface RootState {
  example: ExampleStateInterface
}
export default createStore<RootState>({
  modules: {
    example: exampleModule
  }
})

Despues en cada modulo/index.ts tengo que traerme todo a ese index de ese modulo y usar Module<T,RootState> para tipar el modulo,ojo:

import { Module } from "vuex";
import { RootState } from "..";

import state, { ExampleStateInterface } from "./state";
import actions from "./actions";
import getters from "./getters";
import mutations from "./mutations";

const exampleModule: Module<ExampleStateInterface, RootState> = {
  namespaced: true,
  actions,
  getters,
  mutations,
  state,
};

export default exampleModule;

El state de cada modulo es muy parecido,solo que ahora tenemos que tipar el retorno de la funcion con una interfaz:

En cada modulo/state.ts:

export interface ExampleStateInterface {
  prop: boolean;
}

function state(): ExampleStateInterface {
  return {
    prop: true,
  };
}

export default state;

Las actions de cada modulo,asi como los getters o mutations se traen un Record o Map de la libreria vuex para saber donde quedan con respecto al modulo y al RootState(igual que el Module<T,R>anterior):

En cada modulo/actions.ts(fijate en el ActionTree<T,R>)

import { ActionTree } from "vuex";
import { ExampleStateInterface } from "./state";
import { RootState } from "..";

const actions: ActionTree<ExampleStateInterface, RootState> = {
  someAction(/*{ commit }, payload  */) {
    // a line to prevent linter errors
  },
};

export default actions;

Y lo mismo para los getters:
En cada modulo/getters.ts(fijate en el GeterTree as Map)

import { GetterTree } from "vuex";
import { ExampleStateInterface } from "./state";
import { RootState } from "..";

const getters: GetterTree<ExampleStateInterface, RootState> = {
  someGetter(/* state */) {
    // return true;
  },
};

export default getters;

Sin embargo,las mutations si que parece que van con scope y no necesitan saber el RootState,solo usan MutationTree<T> donde T es la interfaz que tipa el state del modulo y no del store entero.Importante.

En cada modulo/mutations.ts
import { MutationTree } from "vuex";
import { ExampleStateInterface } from "./state";

const mutation: MutationTree<ExampleStateInterface> = {
  someMutation(/* state: ExampleStateInterface */) {
    // a line to prevent linter errors
  },
};

export default mutation;

Fijate que al exportar por defecto el modulo/index.ts puedo llamarlo despues en el store/index como quiera a cada modulo,etc.Muy interesante esto.Fijate tmb como hemos hecho todo con una interfaz para el RootState y otra por cada state de cada modulo.
Recuerda que he hecho fork del gist

    VIDEO 329 PRIMER MODULO EN TS - PLACES MODULE

Sustituimos el cascaron por el modulo places en todo el submodulo y el modulo root:

export interface GeolocationState{
  isLoading: boolean;
  // MapBox trabaja con [lng,lat] y GoogleMaps con [lat,lng]
  // debe ser opcional por que al principio no sabremos la location
  userLocation?: [number, number]; //[lng,lat]
}

function state(): GeolocationState{
  return {
    isLoading: true,
    // undefined para verlo siempre en el store
    userLocation: undefined,
  };
}

export default state;

NOTA: dado que estamos ante una aplicacion que trabaja fuertemente con mapas podemos crear una primera guard clause para mostrar un fallback si el usuario no tiene la geolocalización activada en el browser:

// el objeto navigator siempre existe(en realidad será window.navigator),si su propiedad geolocation es undefined mostramos esto,ni siquiera creamos la aplicación de Vue(importante el punto de llamada)
if (navigator.geolocation === undefined) {
  window.alert("Tu navegador no tiene activada la geolocalización");
}
createApp(App).use(store).use(router).mount("#app"); <- ni siquiera creamos la app de Vue,ojo

      VIDEO 330 ACTION GET-INITIAL-LOCATION

Lo primero vamos a crear un getter que nos diga si está la geolocation ready o no:
  isUserLocationReady(state): boolean {
    return !!state.userLocation;
  },

En cuanto a la action es muy sencilla,basta con usar el objeto navigator con navigator.geolocation.getCurrentPosition((position) => {},(error) => {}) que trae dos callbacks como argumento,la primera con la position,la segunda opcional con el error.
Fijate que en el momento de llamar a la mutation realmente no la tenemos creada pero Vue no da ningun error.Quizas con el tiempo arreglen esto:

const actions: ActionTree<PlacesState, RootState> = {
  getInitialLocation({ commit }) {
    // fijate que la sign dice que getCurrentPosition necesita una successCallback
    navigator.geolocation.getCurrentPosition(
      (position) => commit("setLngLat", position.coords),
      (error) => {
        console.error(error);
        throw new Error(`Unable to get position due to error: ${error}`);
      },
    );
  },
};

IMPORTANTE: son las mutations las que cambian el state en Vue.Fijate que mutation es un objeto,igual que getters o actions.Despues cada propiedad es una funcion:

const mutation: MutationTree<PlacesState> = {
 setLngLat(state:PlacesState,coords:[number,number]){
  state.userLocation=coords;
  state.isLoading=false;
 } 
}

Faltará hacer el dispatch de la action en el primer momento que se pueda

      VIDEO 331 COMPOSABLE USE-PLACES-STORE

Fernando explica que realmente no es buena idea ir por cada componente e ir llamando al const store = useStore() en el setup de cada componente.

Es bastante más limpio crear composable functions/hooks y abstraer la lógica.Fijate que el hook ni siquiera va a devolver nada,pero si que es importante que compruebe si ya hay un valor previo:

export const usePlacesStore = () => {
  const store = useStore<RootState>();

  // no se yo si importa este lifecycle(no sería relativo al componente y ya se ha montado siempre??),nevermind,comprobamos si la location es undefined y si lo es llamamos a la action
  onMounted(() => {
    if(!store.getters['places/isUserLocationReady']){
      store.dispatch('places/getInitialLocation');
    }
  })
// parece que el return es obligatorio(realmente lo es ??)
   return { }
}

Por último la funcion navigator.geolocation.getCurrentLocation((location:GeolocationCoordinates)) devuelve un objeto de ese tipo con varias propiedades,solo queremos la longitue y latitude,en ese orden por estar usando MapBox:

const mutation: MutationTree<PlacesState> = {
  setLngLat(state: PlacesState, coords: GeolocationCoordinates) {
    
    // coors es un objeto de tipo GeolocationCoordinates con varias propiedades,entre ellas latitude y longitued
    // console.log({ coords });
    
    state.userLocation = [coords.longitude, coords.latitude];
    state.isLoading = false;
  }

  NOTA: onMOunted es una callback que se dispara inmediatamente despues de que se monete el componente.No creo que importe en el hook

    VIDEO 332 PREPARAR EL ESPACIO PARA COLOCAR EL MAPA

Por primera vez vamos a separar el contenido del script a un file .ts y dejar la template y el css en el .vue.

En el MapView.vue hay que importar el script asi:
* La primera linea es el import del file TS( que será MapView.ts)
<script lang="ts" src="./MapView"></script>
<template>
  <h1>Mapview </h1>
</template>

<style scoped>
</style>

NOTA: fijate que un componente de Vue es un file con extension .vue,esto es lo que hay que importar siempre:

// fijate que tengo que apuntar al MapView.vue(que es un componente de Vue además) ya que si dejo solo MapView apunto al TS y eso no es nada.hay que apuntar al .vue
import MapView from "@/components/mapview/MapView.vue";

Y en el TS metemos el contenido del script(fijate que es el contenido,la etiqueta se quedó en el file .vue):

import { defineComponent } from "vue";

export default defineComponent({
  name: "MapView",

  setup() {
    
    return {
      
    };
  },
});

Bastante interesante todo esto.Tras esto llamamos a este componente en el HomeView y retornamos lo necesario en el hook.Fijate que estamos usando computed properties para todo:

  return {
    // state
    isLoading: computed(() => store.state.places.isLoading),
    userLocation: computed(() => store.state.places.userLocation),
    // getters
    isUserLocationReady:computed<boolean>(() => store.getters['places/isUserLocationReady'])
  };

Fijate tmb que hubo que tipar a computed<T> para que sepa que es un bool

      VIDEO 333 LOADING Y REFERENCIA AL CONTENEDOR DEL MAPA

Exponemos el getter tmb por el hook y simplemente creamos dos divs,uno con el v-if y el otro con el v-else.El div con el map tenemos que ponerle una referencia al elemento html,a ese div.Para ello hay que crear una variable reactiva en el archivo controlador de TS y mandarla a la template,donde la asignamos:

  setup() {
    const mapElement = ref<HTMLDivElement>();
    const { isLoading, userLocation,isUserLocationReady } = usePlacesStore();

    return {
      isLoading,
      userLocation,
      isUserLocationReady,
      mapElement
    };
  },

  En la template enlazada a ese controlador:
  <div class="map-container" v-else ref="mapElement">

IMPORTANTE: la referencia esta fallando porque el v-else no crea el div el primer render(crea el del v-if y en la segunda pasada el del v-else).Por esto va a fallar el referenciado,pues lo hace al principio; hay que usar un v-show para que cree los dos divs y no falle el referenciado

  <div class="map-container" v-show="isUserLocationReady" ref="mapElement"> <- V-SHOW!!

        VIDEO 334 MOSTRAR MAPA DE MAPBOX

Web de registro: https://account.mapbox.com/
Docu: https://docs.mapbox.com/mapbox-gl-js/guides/
Si bien Google Maps el primer año es gratis ya desde el principio va a pedir una credit card,asi que vamos a la web de MapBox y nos registramos.
Creo un token(con full permisos)

Para instalarlo hay varias opciones,usaremos la libreria con npm.Los estilos tmb los podemos importar en cada file,pero usaremos la CDN asi siempre estarán listos(hay que instalar los definition types en TS):

Despues es simplemente llamar mediante el objeto que exponen a la clase Map(new mapboxgl.Map) y creará un mapa en el container que le pasemos(fijate que pide un id pero la ref me vale).También tenemos la position del user en el store.

  setup() {
    const mapElement = ref<HTMLDivElement>();
    const { isLoading, userLocation, isUserLocationReady } = usePlacesStore();

    const initMap = () => {
      // las refs pueden ser undefined,mejor protegerse
      if (!mapElement.value || !userLocation.value) return;

      // fijate que Mapboxgl.Map crea una instancia cada vez que se llame
      const map = new Mapboxgl.Map({
        container: mapElement.value, // container ID(LA REF ME VALE!!, es un ID!!)
        style: "mapbox://styles/mapbox/streets-v12", // style URL
        center: userLocation.value, // starting position [lng, lat]
        zoom: 15, // starting zoom
      });
      return map;
    };

      onMounted(() => {
      if (isUserLocationReady.value) return initMap();
    });

    return {
      isLoading,
      userLocation,
      isUserLocationReady,
      mapElement,
      initMap
    };
  },

Sin embargo no parece que cargue del todo bien el mapa

  VIDEO 335 MOSTRAR MAPA TAN PRONTO TENGAMOS LA UBICACION DEL USUARIO

En resumen lo que queremos es poner un watcher en el isUsrLocationReady.Fijate que obtener la geolocation es asincrono y el componente se monta antes casi siempre(ademas que era isUserLocationReady.value,pues isUserLocationReady siempre existe )

NOTA: usa un <MapView v-if="isUserLocationReady" /> al llamar al componente es la solución fácil,pero un watcher hace al componente autosuficiente y nos enseña como implementar la solución difícil.

TIP:fijate que podemos disparar el watch inmediatamente:
watch(isUserLocationReady, (newVal) => {
  console.log({ newVal });
  // initMap();
},{immediate:true});

Pero esto es como un useEffect sin dependencias,solo se dispara una vez y estariamos en las mismas.
watch(isUserLocationReady, (newVal) => {
  if(newVal) initMap();
});

NOTA: si bien Fernando tuvo que hacer asincrona la function initMap Vue expone la funcion nextTick para esperar un render.Amazing:

  if (newVal) nextTick(() => initMap());

      VIDEO 336 POPUPS Y MARCADORES

Realmente es simplemente leeer su documentación,pero para crear marcadores necesitaré una posicion y añadirlos al mapa y los popups hay que añadirlos a algun elemento,como un marcador:


  const myLocationPopup = new Mapboxgl.Popup({
      offset: [0, -35],
      maxWidth:"none",
      closeButton: false,
    }).setLngLat(userLocation.value).setHTML(`
    <h4>Aquí estoy</h4>
    <p>Actualmente en Bizkaia</p>
    `);

   // crear marcador new Marker(options).setLngLat([number,number]).addTo(MapboxMap)
    new Mapboxgl.Marker()
      .setLngLat(userLocation.value)
      .setPopup(myLocationPopup)
      .addTo(map);

Ahora se nos presenta un problema,y es que necesitamos la instancia del mapa de forma global y en singleton,ya que queremos añadir cosas a ese mapa,al mismo siempre.

      VIDEO 337 MODULO MAP

Eventualmente vamos a querer tener acceso al mapa desde otros componentes(como el boton de regresar a mi ubicación o agregar marcadores dinámicos).El mapa debe estar en un ámbito global(la instancia).

Este nuevo MapState lucirá asi:

import Mapboxgl from "mapbox-gl";

export interface MapState {
  // el mapa será undefined mientras carga inicialmente.
  map?: Mapboxgl.Map;
  markers: Mapboxgl.Marker[];
  // distancia y duracion del trayecto
  distance?: number;
  duration?: number;
}

function state(): MapState {
  return {
    map: undefined,
    markers: [],
    distance: undefined,
    duration: undefined,
  };
}

export default state;

El siguiente paso será establecer el mapa en el store

    VIDEO 338 MUTATION SET MAP

Dado que establecer el mapa es una accion sincrona vamos a usar una mutation:

const mutation: MutationTree<MapState> = {
  setMap(state, payload: Mapboxgl.Map) {
    return (state.map = payload);
  },
};

Y vamos a crear una composable function que simplemente exponga las entradas al store(fijate que en este punto pueden tomarse varios caminos como simplemente llamar al store en el componente y disparar esa mutation,pero diria que nunca será mala idea crear estos refactors que quedan super reutilizables):

export const useMapStore = () => {

  const store = useStore<RootState>();

  return {
    map: computed(() => store.state.map.map),
    distance: computed(() => store.state.map.distance),
    duration: computed(() => store.state.map.duration),
    // fijate que la mutation no es una computed
    setMap: (map: Mapboxgl.Map) => store.commit('map/setMap',map)
  }
}

NOTA: fijate que el hook simplemente expone lo que queremos,no necesitó lógica en el body,me está confundiendo esto y limitando,pero es una simple funcion,asinto,puede hacer lo que yo quiera
Ya solo es llamar al setMap(pero no va a disparar el setter de nuevo??):
  const { setMap } = useMapStore();

    VIDEO 339 BOTON PARA VOLVER A LA UBICACION CENTRAL

En este punto es muy sencillo todo,pero fijate en un par de cosas:
Primero: a las computed tengo que acceder con .value tmb
Segundo: es realmente buena idea crear tantas computed ??

Tercero: puedo crear una computed que sea la mezcla de otras dos,recuerda que las boolean las tengo que tipar o vienen como computed<any>(supongo que esto será extensible a casi todo más adelante)

Aparte de estas dudas fijate que el método es map.flyTo(options) para que vuelva con una animacion muy bonita:

 setup() {

    const { map,isMapReady } = useMapStore();
    const { userLocation,isUserLocationReady } = useGeolocationStore();

    const goToOriginalPosition = () => {
      if (!map.value) return;
      if (!userLocation.value) return;

      map.value.flyTo({
        center: userLocation.value,
        zoom: 12,
      });
    };

    return {
      isBtnReady: computed<boolean>(() => isUserLocationReady.value && isMapReady.value),
      goToOriginalPosition,
    };
  },

  Y el botón lo mostramos con un v-if computando esa computed.Genial:
  <button v-if="isBtnReady"  class="btn btn-primary" @click="goToOriginalPosition">Ir a mi ubicación</button>

        VIDEO 340 SEARCH-RESULTS COMPONENT 

Video de maquetacion.Ojo con el error de la etiqueta script y su atributo src.

    VIDEO 341 IMPLEMENTAR DEBOUNCE MANUALMENTE

Implementaremos un debounce para que no tire una peticion el input de los venues en cada keyPress.
NOTA: el input de Quasar ya viene con esta feature,pero como estamos con Bootstrap montremos uno manualmente

Lo que vamos a hacer es bastante sencillo(y extrapolable a cualquier fwk).Crearemos dos states,uno al valor final y otro al timer:

const timer = ref();
const finalValue = ref('');

return {
  finalValue,
  searchTerm: computed({
    get(){ return finalValue.value},
    set(val:string){
      // si ya hay un timer lo primero es limpiarlo,es decir,que el usuario en cuanto escriba lo primero que va a hacer el borrar el timer
      if(timer.value) clearTimeout(timer.value);
      // y volvemos a montar el timer,y cuando el usuario deje de escribir siempre tendrá un timer nuevo que al de 500ms establecerá el valor 
      timer.value = setTimeout(() => {
        finalValue.value = val
      },500)
      }
  })
}

En React podriamos hacer lo mismo
const [timer,setTimer] = useState<Node.Timer>(null);
const [finalValue,setFinalValue] = useState(")
* en el onChange del input
const handleChange = (evt) => {
  if(timer) clearTimeout(timer);
  setTimer(setTimeout(() => {
    setFinalValue(evt.target.value)
  },500));
}
Y al JSX expongo(o a la peticion) el getter finalValue

      VIDEO 342 MAPBOX SEARCH API E INTERFACES

Docu para su Search API: https://docs.mapbox.com/playground/geocoding/
Tenemos que hacer un GET con varios queryParams.Ejemplo:

https://api.mapbox.com/geocoding/v5/mapbox.places/-74.01376728733808,40.78241512806966.json?limit=1&access_token=YOUR_MAPBOX_ACCESS_TOKEN

Empecemos creando la action:
  async searchPlacesByTerm({commit,state},query:string) {
   console.log('vuex: ',query) 
  }
Y la exponemos por el hook usando buenas prácticas:
   searchPlacesByTerm: (term = "") => store.dispatch("geolocation/searchPlacesByTerm", term),
Ya solo es llamarla en el setter de la computed property

    VIDEO 343 REALIZAR PETICION HTTP

Lo primero es instalar axios.Despues creamos una instancia con nuestros params(fijate que podemos poner en duro varios):

const searchApi = axios.create({
  baseURL: 'https.//...',
  params:{
    limit:5,
    language:'es',
    access_token:'pk.ey...'
  }
})
Obviamente falta alguno que será dinámico.Esto debo interpretarlo correctamente siempre.

Y ya con esta instancia podemos realizar la peticion en la action.Fijate que nos falta el params proximity y el segmento de busqueda dinámico:

  const resp = await searchApi.get<PlacesResponse>(`/${query}.json`,{
    params:{
      proximity: state.userLocation?.join(',')
    }
   })
Ojo que los params van concatenados con una coma,join nos viene perfecto para pasar de un array a una concatenacion de strings con el separador que le indiquemos.

    VIDEO 344 ALMACENAR LA BUSQUEDA EN EL STORE

Creamos dos propiedades más en el state del modulo(isLoadingPlaces y places de tipo Feature[]).Creamos las mutations que cambien ese state:
  
  setIsLoadingPlaces(state, loading: boolean) {
    state.isLoadingPlaces = loading;
  },
  setPlaces(state, places: Feature[]) {
    state.places = places;
  },

Ya solo es commitear estas mutations en la action y comprobar que se guardan los 5 places en el store:
  async searchPlacesByTerm({ commit, state }, query: string): Promise<Feature[]> {
    if (query.length === 0) {
      commit("setPlaces", []);
      return [];
    }

    commit("setIsLoadingPlaces", true);
    const resp = await searchApi.get<PlacesResponse>(`/${query}.json`, {
      params: {
        proximity: state.userLocation?.join(","),
      },
    });
    commit("setIsLoadingPlaces", false);
    commit("setPlaces", resp.data.features);
    return resp.data.features;
  },

  VIDEO 345 MOSTRAR LA BUSQUEDA EN EL COMPONENTE DE RESULTADOS

Exponemos mediante el hook el loading y los places y los mandamos a la template para iterar con un v-for:

  const { places, isLoadingPlaces } = useGeolocationStore();
  return {
    places,
    isLoadingPlaces,
  };

  En la template iteramos(fijate en el uso del v-else-if para comprobar,muy interesante):
   
   <!-- loading -->
  <div v-if="isLoadingPlaces" class="alert alert-primary text-center">
    <h5>Cargando</h5>
    <span>Espere por favor...</span>
  </div>
<!-- realmente no es un v-else sino un v-else-if  -->
  <ul class="list-group mt-2 mb-1" v-else-if="places.length > 0">
    <li
      v-for="place in places"
      :key="place.id"
      class="list-group-item list-group-item-action"
    >
      <h5>{{ place.text_es }}</h5>
      <p>
        {{ place.place_name_es }}
      </p>
      ...

    VIDEO 346 ACTIVAR LUGAR Y MOVER LA CÁMARA

Cuando hagamos click en un <li> queremos poner ese list-item activo y mostrar la polyline(y mover la camara hacia ese destino tmb).Fijate que hay varias formas de crear clases condicionales,ya que no siempre voy a necesitar un ternario:

 <li
      v-for="place in places"
      :key="place.id"
      class="list-group-item list-group-item-action"
      :class="{'active':place.id === activePlace}"
      @click="() => onPlaceClicked(place)"
    >
      <h5>{{ place.text_es }}</h5>
      <p>
        {{ place.place_name_es }}
      </p>
      <div class="text-end">
        <button
          class="btn"
          :class="place.id === activePlace ? 'btn-outline-light' : 'btn-outline-primary'"
        >
          Direcciones
        </button>
      </div>
    </li>

Fijate tmb como hay que pasar todo el place para hacer el flyTo

      VIDEO 347 COLOCAR MARCADOR EN CADA LUGAR ENCONTRADO

Para borrar un marcador no basta con borrarlo del arreglo en el store,sino que hay que llamar a un método de la libreria Mapbox en este caso.

Todo va a comenzar con un listener en los places,que es justo lo que queremos.Adicionalmente hay que limpiar el place activo,ojo:
   watch(places, (newPlaces) => {
      activePlace.value = "";
      setMarkers(newPlaces);
    });


Despues creamos una mutation barriendo los places,etc:
  setMarkers(state, payload: Feature[]) {
    // para borrar los marcadores hay que llamar a remove y reasignar a un arreglo vacio
    state.markers.forEach((marker) => marker.remove());
    state.markers = [];

    payload.forEach((feature) => {
      const [lng, lat] = feature.center;
      const popup = new Mapboxgl.Popup({
        offset: [0, -35],
        maxWidth: "none",
        closeButton: false,
      }).setLngLat([lng, lat]).setHTML(`
          <h4>${feature.text_es}</h4>
          <p>${feature.place_name_es}</p>
      `);
      const marker = new Mapboxgl.Marker()
        .setLngLat([lng, lat])
        .setPopup(popup)
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        .addTo(state.map!);
      state.markers.push(marker);
    });
  },

    VIDEO 348 OBTENER RUTA ENTRE DOS PUNTOS

Directions API: https://docs.mapbox.com/api/navigation/directions/
Playground: https://docs.mapbox.com/playground/directions/

Nos queda que al darle click en el botón Direcciones(quizás mejor otro nombre) se trace la ruta entre la ubicación actual y el marcador.Mapbox ya ofrece todo esto en su API.

NOTA: para estas operaciones usaremos la directions API(dentro de Navigations).Fijate que anteriormente hemos usado la Search API

Un ejemplo de llamada seria(es un GET):
https://api.mapbox.com/directions/v5/mapbox/driving/-74.507147%2C40.567768%3B-73.564294%2C40.76997?alternatives=true&geometries=geojson&language=en&overview=simplified&steps=true&access_token=pk.eyJ1Ijoib3NjYXJnbTQwIiwiYSI6ImNrbHhoZ2I0dTNhMmsydm4xdGhlaHF3MzAifQ.vyYKwnF9auoGxBwkI6LivA

Donde driving podia ser tmb (traffic | walking | cycling), alternatives a true traza otras posibles rutas y steps a true muestra una guia con los steps a seguir

NOTA:en los tipos para el queryParam geometries usaremos geojson pero Fernando recalca que polyline tmb es una opcion que el enseña en su curso de Flutter pero hay que decodificar la polyline

Asi pues tras analizar el endpoint creamos otra instancia de axios para fijar los params(muy útil esto).

const directionsApi = axios.create({
  baseURL:
    "https://api.mapbox.com/directions/v5/mapbox/driving",
  params: {
    alternatives: false,
    geometries: "geojson",
    overview: "simplified",
    steps: false,
    access_token: process.env.VUE_APP_MAPBOX_KEY,
  },
});

NOTA: falta un segmento con las coordenadas,pero fijate que 3B significa punto y coma luego será /driving/lng,lat;lng,lat&params
donde la primera lng,lat es el starting point y la segunda el ending point.
Por último tipamos la Response con quicktype.io

    VIDEO 349 OBTENER INFORMACIÓN DE LA RUTA POR PLACE

Realmente no tiene mucho realizar la peticion,pero fijate que es una action.La meteremos en el modulo del map.Fijate que join viene que ni pintado:

export type LngLat = [number, number];
export interface ITraceRouteArgs {
  start: LngLat;
  end: LngLat;
}
const actions: ActionTree<MapState, RootState> = {
  async traceRoute({ commit }, { start, end }: ITraceRouteArgs) {
    const resp = await directionsApi.get<DirectionsResponse>(
      `/${start.join(",")};${end.join(",")}`,
    );
    // solo nos interesa la primera ruta,y de ella sus coordenadas
    console.log(resp.data.routes[0].geometry.coordinates);
  },
};

Fijate de nuevo que usar un hook para centralizar el acceso al store parece una buena solución para aplicaciones pequeñas.Ya solo falta definir la funcionalidad para el click sobre el boton de trazar ruta:
  <button
    class="btn"
    :class="place.id === activePlace ? 'btn-outline-light' : 'btn-outline-primary'"
    @click.self="() => traceRoute(place.center)"
  >
  Trazar ruta
  </button>

  const traceRoute = (end: number[]) => {
  if (!userLocation.value) return;
  const start = userLocation.value;
  getRouteBetweenPoints(start, end as LngLat);
};

      VIDEO 350 MOSTRAR LA POLYLINE EN EL MAPA

En este punto y teniendo ya todo el arreglo de arreglos de coordenadas que nos devuelve la petición a directions Api basado en dos puntos simplemente es seguir su documentación.
Fijate como hay varios pasos/abstracciones a seguir para agregar esta linea:


  setRoutePolyline(state, coords: number[][]) {
    const start = coords[0];

    // NOTA: agregar una Boundary se asegura que la Polyline quepa en el mapa,redimensionandolo segun la Boundary

    // PASO UNO : definir unas Boundaries con la clase LngLatBounds,empezarán en el punto inicial
    const bounds = new Mapboxgl.LngLatBounds(
      // porque repetimos las mismas coords ??
      [start[0], start[1]],
      [start[0], start[1]],
    );
    // PASO 1.5 ir agregando más puntos/coordenadas a la Boundary con el método extend
    coords.forEach((coord) => {
      const newCoord: LngLat = [coord[0], coord[1]];
      bounds.extend(newCoord);
    });

    // PASO DOS : agregar esta Boundary al mapa con map.fitBounds(hay que dar un pequeño padding general en las options del segundo argumento)
    state.map?.fitBounds(bounds, {
      padding: 300,
    });

    // PASO TRES: definir una Source(ojo con el tipo)
    const sourceData: Mapboxgl.AnySourceData = {
      type: "geojson",
      data: {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            properties: {},
            geometry: {
              type: "LineString",
              coordinates: coords,
            },
          },
        ],
      },
    };
    
    // PASO CUATRO añadir esa source.Ojo,el primer argumento pide un string que debe ser el ID de la capa del paso cinco.Ojo,si ya hubiera una Layer con el mismo ID debo borrar la capa y el Source
    const MY_LINE_ID = "MyPolylineLayer";
    if (state.map?.getLayer(MY_LINE_ID)) {
      state.map?.removeLayer(MY_LINE_ID);
      state.map?.removeSource(MY_LINE_ID);
    }
    // NOTA: addSource va a crear una Source con el mismo ID que la capa,asi que al añadir o borrar la capa o la source los literales van a coincidir.Además las propiedades id y source de la Layer tienen el mismo literal como valor obviamente
    state.map?.addSource(MY_LINE_ID, sourceData);

    // PASO CINCO añadir la Layer(la Polyline).Ojo que el ID debe hacer match con el step 4
    state.map?.addLayer({
      id: MY_LINE_ID,
      type: "line",
      source: MY_LINE_ID,
      layout: {
        "line-cap": "round", //bordecitos de la linea redondeados
        "line-join": "round",
      },
      paint: {
        "line-color": "black", // cualquier color o hexadecimal
        "line-width": 3,
      },
    });
  },

        VIDEO 351 BORRAR LA POLYLINE

Si cambian los marcadores no tiene sentido que siga la polyline,asi pues en la mutation setmarkeers podemos resetearla perfectamente al final de la mutation:

    // si los marcadores han cambiado no tiene sentido tener la polyline
    if (state.map.getLayer(MY_LINE_ID)) {
      state.map.removeLayer(MY_LINE_ID);
      state.map.removeSource(MY_LINE_ID);
      state.distance = undefined;
      state.duration = undefined;
    }

      VIDEO 352 ALMACENAR DISTANCIA Y DURACION

      
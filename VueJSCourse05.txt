    SECCION 16 AUTENTICACION  EN NUESTRA JOURNAL APP

FH recomienda no mezclar la Options API con la Composition API,aunque lo vamos a hacer en esta sección dado que tenemos la app en la Options API.
Colocaremos interceptores de axios en las rutas también.

Esta sección tiene por objetivo que pongamos en práctica lo aprendido en el composition API en nuestra aplicación de diario. Puntualmente tocaremos los siguientes temas:

1 -Vuex composables
2- Custom composables para acceder al store
3- Manejo de autenticación
4- Guards aplicados
5- Manejo de tokens
6- Estado de la autenticación
  a- Autenticando
  b- Autenticado
  c- No Autenticado
7- Mutaciones dentro de composables
8- Acciones dentro de composables
9- Interceptores

        VIDEOS 261-263

Traer la template del zip y crear los componentes y sus rutas.
En el video de crear el store fijate que los tengo que combinar con createStore:

import { createStore } from 'vuex';
import journalModule from '../modules/daybook/store/journal';
import authModule from '@/modules/auth/store';

const store = createStore({
modules:{
  journal: journalModule,
  auth: authModule
}
})

export default store

Y cada xxxModule es un objeto que luce asi.:

import state from './state';
import * as actions from "./actions";
import * as getters from "./getters";
import * as mutations from "./mutations";

const authModule = {
  namespaced:true,
  actions,
  getters,
  mutations,
  state
}

export default authModule;

    VIDEO 264 FORMULARIO - USE AUTH HOOK

Fijate que sencillo es enganchar un formulario con Vue a una ref y disparar el Submit(desde luego es ridiculamente sencillo):
<form>
  <input v-model="userForm.name" .... /> <- campo cualquiera
  <input v-model="userForm.email" .... />
  <button @submit.="onSubmit"
</form>

setup(){
  const userForm = ref({
    name:"",
    email:""
  })
  return {
    userForm,
    onSubmit: async() => handleSubmit
  }
}

      VIDEO 265 OBTENER TOKEN DE ACCESO DE FIREBASE

Habilitamos el modulo de Authentication,y elegimos custom email/password.Fijate que dado que es una app muy sencilla ni siquiera vamos a usar el firebase.config sino que vamos a apuntar a un endpoint que ya exponen ellos mandando una API_KEY.

IMPORTANTE: el endpoint es "https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=[API_KEY] luego el unico queryParam es 'key'

NOTA:el endpoint es el mismo,mediante la api_key ya sabe que proyecto es(fijate que tengo que ir a configuracion de proyecto/Clave de API Web y copiar el token a mandar a ese endpoint).


PASO UNO: Refactorizar la instancia de axios(luce asi):

const authApi = axios.create({
  baseURL: "https://identitytoolkit.googleapis.com/v1/accounts",
  params: {
    key: process.env.VUE_APP_FIREBASE_TOKEN,
  },
});

export default authApi;

IMPORTANTE: este endpoint es un POST quepide un body con estas tres propiedades:
{
  email:...
  password:...
  returnSecureToken: <- booleano que debo mandar a true para que devuelva el token que necesitamos
}

PASO DOS: creamos la accion asincrona:
* En el actions.js de ese modulo
export const createUser = async ({ commit }, user) => {
  const { name, email, password } = user;

  try {
    const { data } = await authApi(":signUp", {
      email,
      password,
      returnSecureToken: true, <- fijate en las tres props obligatorias
    });
    console.log(data)

    return { ok: true };
  } catch (error) {
    return { ok: false, message: error.response.data.error.message  };
  }
};

PASO TRES: la action la llamamos en el hook,que lo llamará el componente,etc:
* Composable *
export const useAuth = () => {
  const store = useStore();

  const createUser = async (user) => {
    // ojo que es una accion asincrona y debo usar await
    return await store.dispatch("auth/createUser", user);
  };

  return {
    createUser,
  };
};

    VIDEO 266 ACTUALIZAR EL DISPLAY NAME DEL USUARIO

Si nos fijamos bien Firebase tiene un hueco para meter un Name a ese usuario, vamos a cambiarlo/mostrarlo tmb.Sin embargo el endpoint solo pedia un objeto con las props email,password y returnSecureToken.

Para poder cambiar el perfil tenemos que actualizarlo,puedo ver en la documentación que aunque se haya logeado por custom pass puedo cambiar el displayName,la photoUrl y alguna cosa mas(muy interesante pues)

IMPORTANTE: el endpoint esta vez es "https://identitytoolkit.googleapis.com/v1/accounts:update?key=[API_KEY]. Solo cambia el :signUp.

De nuevo es un POST,sin embargo el objeto tiene otro tipado(ojo que siempre va a pedir un idToken correcto:
{
  idToken,
  displayName?,
  photoUrl?,
  returnSecureToken?,
  refreshToken?
} <- el objeto a mandar en el update luce asi(solo el idToken required)

 try {
    const { data } = await authApi.post(":signUp", {
      email,
      password,
      returnSecureToken: true,
    });
    
    // para el update necesito mandar el idToken que me retorna un signUp exitoso(fijate que le puedo mandar un name y una foto,asin)
    const { idToken } = data;

    // y lanzo el update para el displayName
    await authApi.post(":update", {
      displayName:name,
      idToken,
    });
 }

      VIDEO 267 MUTATION LOGIN USER

No puede ser más sencilla.Recuerda que es una mutation:

export const loginUser = (state, { user, idToken, refreshToken }) => {
  if (idToken) {
    localStorage.setItem("idToken", idToken);
    state.idToken = idToken;
  }

  if (refreshToken) {
    localStorage.setItem("refreshToken", refreshToken);
    state.refreshToken = refreshToken;
  }

  state.user = user;
  state.status = "authenticated";
};

Y la action la llamará asi.Fijate que al estar en el mismo modulo me puedo ahorrar 'auth/loginUser':
  delete user.password;
  commit('loginUser',{user,idToken,refreshToken})

    VIDEO 268 MENSAJE ERROR EN EL REGISTER

Dado que ahora tenemos un ok:true o false como respuesta podemos informar al usuario del error.No solo eso, tambien debo redireccionar al usuario si es un registro exitoso.
        
  if(!ok) Swal.fire('Error',message,'error')
  else router.push({name:'no-entry'})

    VIDEO 269 ACTIONS -LOGIN DE USUARIO

Practicamente es hacer lo mismo(ojo que cambia el final del endpoint,son diferentes todos y es ':signInWithPassword'):

  try {
    const { data } = await authApi.post(":signInWithPassword", {
      email,
      password,
      returnSecureToken: true,
    });

NOTA: recuerda que el @submit.prevent lo lleva la etiqueta <form></form>

Los Websockets son una tecnologia que permite una comunicación bidireccional entre cliente y servidor sobre un único socket TCP.En cierta manera son un buen sustituto de AJAX como tecnología para obtener datos del servidor,ya que no tenemos que perdirlos,el servidor nos lo enviará cuando haya nuevos

      VIDEO 270 ACTUALIZAR EL DISPLAY NAME DE FIREBASE

Realmente el error era en el nombre de la propiedad.No habia error de lógica.En el siguiente video vamos a solucionar la pérdida de los datos del store en cada refresh

      VIDEO 271 COMPROBAR EL ESTADO DEL IDTOKEN

Para solucionar este problema Firebase permite intercambiar un refreshToken por un idtoken apuntando a este endpoint(igual que los anteriores pero esta vez con :lookup).Ojo,que es un POST y pide un { idToken: '23423424kfks'} :

https://identitytoolkit.googleapis.com/v1/accounts:lookup?key=[API_KEY]

Con todo esto creamos una action que comprobará el status(en realidad comprobará si hay un idToken y si lo hay vuelve a logear al usuario,almacenando todo de nuevo.Si no hay un idToken limpiamos todo y deslogeamos):

export const checkAuthStatus = async ({ commit }) => {
  const idToken = localStorage.getItem("idToken");
  const refreshToken = localStorage.getItem("refreshToken");

  if (!idToken) {
    // realmente estoy en el mismo módulo asi que no necesitaba el 'auth'
    commit("auth/logout");
    return {
      ok: false,
      message: "No hay idToken",
    };
  }
  try {
    const { data } = await authApi.post(":lookup", { idToken });
    console.log({ data });
    // ojo que Firebase regresa los usuarios en la data(data.users[0]).Siempre habrá solo uno con ese idToken
    const { displayName, email } = data.users[0];

    // creamos un user para volver a logearlo
    const user = {
      name: displayName,
      email,
    };
    commit("loginUser", { user, idToken, refreshToken });
     return { ok: true }; 
  } catch (error) {
    commit("auth/logout");
    return {
      ok: false,
      message: error.response.data.error.message,
    };
  }
};
Aún faltaria llamar a esta action( a través del composable que ya tenemos)

      VIDEO 272 RECARGAR EL ESTADO DE LA AUTENTICACIÓN

Fernando explica que el mejor punto va a ser en el router principal,es decir en el App.vue, de esta forma se propagará la lógica a toda la aplicación.
Lo primero vamos a crearnos un getter hacia la propiedad status en los getters del modulo auth:

export const currentState = (state) => {
  return state.status
};

Despues en el composable vamos a retornar una computed property hacia ese getter(recuerda que computed viene de vue,como ref)

import { computed } from 'vue';

export const useAuth = () => {
  const store = useStore()
  return {
    authStatus: computed(() => store.getters['auth/currentState'])
  }
}
Recuerda tmb que store.getters es un objeto y debo acceder por la key

      VIDEO 273 AUTH GUARD

Lo más importante es entender donde y con qué argumentos puedo llamar a un Guard en Vue.Fijate que lo debo llamar en las rutas de algun router,tengo varios ciclos de vida (beforeEnter,beforeEach,...).Usaremos beforeEnter.Fijate que la firma es beforeEnter: (to,from,next) => {} y que puede ser async perfectamente y además puede ser un arreglo de Guards o uno solo:

const routes = [
  {
    path: "/",
    name: "home",
    component: HomeView,
  },
  {
    path: "/about",
    name: "about",
    // this generates a separate chunk (about.[hash].js) for this route
    component: () => import(/* webpackChunkName: "about" */ "../views/AboutView.vue"),
  },
  {
    path: "/daybook",
    beforeEnter: [isAuthenticatedGuard],
    ...dayBookRoutes,
  },

  En cuanto a ese Guard luce asi:
import store from '@/store'; <- ojo que es el store global

  export const isAuthenticatedGuard = async (to,from,next) => {
    const { ok } = await store.dispatch('auth/checkAuthStatus)
    if(ok) next()
    else next({name:'login'})
  }

  Fijate que el acceso al store mediante un import es necesario ya que el hook es solo para el interior del setup.Sencillo todo
  NOTA: supongo que hay que usar el store global porque el Guard está más arriba que el módulo

        VIDEO 274 LOGOUT Y NOMBRE DE USUARIO

Simplemente creamos un getter hacia state.user.name y en el composable lo exponemos mediante una computed asi como la llamada al commit del logout.Pintamos en la navbar el nombre y en el boton de salir llamamos al logout(redirigimos tmb).
Por último cambiamos las reglas de la DB ahora que ya tenemos la auth funcionando:
{
  "rules": {
    ".read": "auth != null", 
    ".write": "auth != null", 
  }
}
Sin embargo vemos que esto ahora genera 401s.Lo solucionaremos muy fácil con un interceptor de axios:

        VIDEO 275 INTERCEPTORES

Realmente lo único que nos falta es mandar el idToken en cada petición a Firebase.Lo vamos a hacer con interceptores,pero perfectamente lo podemos hacer al crear la instancia tmb:

* FORMA SIN INTERCEPTORES
const journalApi = axios.create({
  baseURL: "https://vue-daybooks-default-rtdb.europe-west1.firebasedatabase.app",
  params:{
    auth: localStorage.getItem('idToken')
  }
});

* FORMA CON INTERCEPTORES(obviamente ya no iria la prop params en el axios.create)

const journalApi = axios.create({
  baseURL: "https://vue-daybooks-default-rtdb.europe-west1.firebasedatabase.app",
});
* usamos la instancia para acceder a interceptors.Siempre se recibe la config de la petición y debo retornarla tras modificarla:

journalApi.interceptors.request.use( (config) => {
  // aqui puedo usar config.headers | config.params etc
  // auth porque Firebase dice que se debe llamar auth
  config.params = {
    auth: localStorage.getItem('idToken')
  }
  return config; <- sie
})

Desde luego es muy sencillo interceptar las requests y/o responses.El siguiente módulo testearemos todo esto(me fallarán muchas de las anteriores ya que estaban sobre un user sin autenticar)

        SECCION 17 COMPOSITION API TESTING

Probar el composition API puede ser engañoso, porque podemos probar literalmente todo o bien sólo lo que se expone en el return del setup y nuestros composable functions.

Esta sección es quizá la más complicada por varias razones, pero no es que no podamos resolverla, puntualmente veremos:

1- Testing autenticado
2- Pruebas generales sobre el Store modularizado
3- MockRouter
4- Pruebas en composables
5- Pruebas con autenticación exitosa y fallida
6- Creación y eliminación de usuario durante pruebas
7- Simular getters del store

Al igual que la sección previa del testing, cuando probamos el Journal usando el options API, aquí crearemos un Store con ambos módulos (Auth y Journal) para que aprendamos como crear un store con la cantidad de módulos que sean necesarios en nuestras aplicaciones futuras

Parte de mi objetivo con todas las pruebas que realizamos durante el curso, es que ustedes tengan un repertorio bastante grande para que puedan probar todo lo que necesiten de sus aplicaciones. 
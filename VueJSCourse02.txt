SECCION 07 POKEMON GAME

En esta sección haremos un juego que nos permita aprender mucho sobre Vue y la comunicación entre componentes. Puntualmente veremos:

1- Mount
2- Axios en Vue.js
3- Emitir eventos
4- Escuchar eventos personalizados
5- Funciones para generar información aleatoria
6- Lógica para resolver la necesidad de la aplicación

VIDEO 87 INICIO DEL PROYECTO

Creamos una nueva aplicación con:
>vue create 04-pokemon-game
Selecciono añadir features manualmente y agrego el unit testing(sino lo agrego tendria que configurar los archivos yo,instalar las libs,etc)
Recuerda no guardar como configuración modelo,ya que es muy simple

Se recomienda esta estructura de directorios para proyectos un poco más grandes que éste.Eventualmente la implementaremos:
src/
+-- modules/
|   +-- moduleA/
|       +-- components/
|       +-- services/
|       +-- helpers/
|       +-- router/
|       +-- store/
|   +-- moduleB/
|   +-- moduleC/

En resumen,no se recomienda usar la estructura por default,sino crear la carpeta src/modules lo primero de todo y despues crear submodulos en base a lógica de negocio,etc
NOTA: puedo omitir la extensión al importar componentes en Vue:
import PokemonPage from "./pages/PokemonPage";

Recuerda también que cuando un componente consuma otros componentes los tiene que importar y exportar también(aparte que cada uno de esos componentes consumidos tiene que exportarse con un name):
<script>
import PokemonPicture from "./../components/PokemonPicture";
import PokemonOptions from "./../components/PokemonOptions";

export default {
  name: "PokemonPage",
  components:{
    PokemonPicture,PokemonOptions
  }
};
</script>

    VIDEO 89 ESTILOS Y MAQUETACIÓN

Fijate como puedo quitar el brillo a una imagen(dejando la silueta en negro) mediante un filter y el método brightness.Recuerda que debo agregar scoped a cad etiqueta de estilos que quiera que sean locales al componente:

<style scoped>
.hidden-pokemon {
  filter: brightness(0);
}
</style>

Como API usaremos https://pokeapi.co.Fijate que los snippets empiezan por vbase ahora

  VIDEO 90 FUNCIONALIDAD DEL POKEMON PICTURE

Vamos a crear una prop de tipo Number.Fijate que para que sea asi tengo que usar v-bind(el shortcut es :):
 
 <PokemonPicture :pokemonId="4" /> === <PokemonPicture v-bind:pokemonId="4" />

 Y para consumir una computed property lo mismo,hay que hacer un v-bind con la misma sintaxis(fijate que hacer un v-bind hace que lo que haya como valor sea interpretado como Javascript y no un string):
  <img
      :src="imgSrc" <- imgSrc es una propiedad computada
      class="hidden-pokemon"
      alt="pokemon"
    />

 La computed se hace asi:
  computed:{
    imgSrc(){
      return `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/dream-world/${this.pokemonId}.svg`;
    }
  } 

    VIDEO 91 LOGICA PARA CAMBIAR DE IMAGENES

Eventualmente el PokemonOptions debería recibir un arreglo de 4 pokemons de forma aleatoria.De momento creamos un arreglo de 650 posiciones asi:

const pokemons = Array.from( Array(650)); 
* Fijate que pokemons ahora mismo es un arreglo de 650 undefined
return pokemons.map( (_,index) => index + 1) <- meto en cada posición su index+1,obteniendo un arreglo de numeros

Ahora los devolvemos al azar.Fijate que fácil va a ser con sort,pues los va a ordenar si son mayores a 0 o menores:
const mixedPokemons = pokemons.sort( () => Math.random() - 0.5) <- esto va a soltar positivos y negativos aleatoriamente,reordenandolos

VIDEO 92 OBTENER NOMBRES DE LOS POKEMONS & REALIZAR PETICION

La idea es llamar al endpoint pokemon/:id,solo por motivos didacticos(ya que era mejor haber usado una con los 650,que incluso es más ligera que el detalle de un pokemon).Empezamos pues instalando axios:
>yarn add axios

Creamos nuestra instancia en la carpeta 'api'
import axios from "axios"

const pokemonApi = axios.create({baseUrl:"xxx"})

Y simplemente creamos un Promise.all:
const getPokemonNames = async ([a, b, c, d] = []) => {
  const [pk1, pk2, pk3, pk4] = await Promise.all([
    await pokemonApi.get(`/${a}`), //  ya mete el await dentro el Promise.all
    pokemonApi.get(`/${b}`), // no es necesario el await interno,asinto
    pokemonApi.get(`/${c}`), //
    pokemonApi.get(`/${d}`), //
  ]);

  return [
    {
      name: pk1.data.name,
      id: pk1.data.id,
    },
    {
      name: pk2.data.name,
      id: pk2.data.id,
    },
    {
      name: pk3.data.name,
      id: pk3.data.id,
    },
    {
      name: pk4.data.name,
      id: pk4.data.id,
    },
  ];
};

IMPORTANTE: fijate que el Promise.all no necesita del await por cada promesa interna,con el suyo ya vale(aunque es indiferente ponerlo o no).Genial,ya tenemos los pokemons
Recuerda usar console.table para objetos(sobre todo en el curro)

VIDEO 93 MOSTRAR LAS OPCIONES POSIBLES- CICLO DE VIDA INICIAL

Vue ya viene con unos métodos predefinidos que son llamados en determinados momentos(al crearse un componente,al destruirse,al cambiar,etc...).Los tengo en el PDF,ojo.
Si miro el PDF puedo ver que me valdría el created o el mounted.Realmente no tiene complejidad,pero ojo,son métodos(igual que data) y no propiedades como methods o computed:

 data(){
    return{
      pokemonArr: []
    }
  },
  methods:{ <- propiedad
    async mixPokemonArray(){
      try{
        this.pokemonArr = await getPokemonOptions();
      }catch(e){
        console.log("Error in the request: ",e)
        this.pokemonArr=[]
      }
    }
  },
  mounted(){ <- lifecycle
    this.mixPokemonArray()
  }

  IMPORTANTE: fijate que no tengo que poner await this.mixPokemonArray().Los ciclos de vida son asincronos por naturaleza,supongo
  Ya solo es recibirlo por props en el otro Cmp e iterar
    <ul>
     <li v-for="pokemon in pokemons">
     {{pokemon.name}}
     </li>
    </ul>

    VIDEO 94 SELECCIONAR UN POKEMON ALEATORIAMENTE

  Creamos una nueva propiedad en el padre para el pokemon que queremos acertar:
  data(){
    return {
      ...
      pokemon:null
    }
  }
    const rndInt = Math.floor(Math.random() * 4);
    // agarro un pokemon de forma aleatoria
    this.pokemon = this.pokemonArr[rndInt];

Sin embargo,fijate que por unos momentos ese pokemon es null y el componente hijo trata de acceder a null.id antes de tener el pokemon,pues es una petición.Hay que corregir esto.Una sería usar un v-if en el padre para que no renderize al hijo:

 <div v-if="pokemon">
    <PokemonPicture :pokemonId="pokemon.id" :showPokemon="true" />
    <PokemonOptions :pokemons="pokemonArr" />
  </div>    

Claro que esto nos hace ver por unos momentos una pantalla en blanco.Aqui entramos en el terreno de los loadings,pero Vue proporciona una directiva muy interesante llamada v-else que va en conjunción con un v-if,lógicamente:
<h1 v-if="!pokemon">Espere por favor...</h1>
<div v-else>
 <h1>¿Quién es este pokémon?</h1>
    <PokemonPicture :pokemonId="pokemon.id" :showPokemon="true" />
    <PokemonOptions :pokemons="pokemonArr" />
</div>

Esta directiva no necesita de ninguna condición,ya que va con su v-if correspondiente,entrando cuando la condición del mismo no se cumpla.
De esta forma me ahorro escribir dos v-if,bien por Vue aqui.


VIDEO 95 $emit - EMITIR EVENTOS HACIA ARRIBA

En este punto nos falta que el onClick sobre una opcion transmita esa opcion hacia el padre,indicando que debe de cambiar de silueta.Vue hace esto de una forma muy sencilla también.

NOTA:hay varias propiedades y/o métodos en el objeto global Vue que son accedidas mediante el símbolo de dollar.Uno de ellos es $emit()
NOTA:si bien en otros lenguajes ese $ puede ser un puntero a memoria en Javascript es un simple caracter adicional que no significa nada,solo da contexto para indicar al desarrollador que es algo propio de Vue,indicandole que no debe tocar nada.

Si por ejemplo solo fuera emit el dev podria pensar que es algo de otra persona y borrarlo o modificarlo.

IMPORTANTE: para acceder a este $emit desde un método en el <script></script> tengo que usar this.$emit().En realidad lo puedo usar en la template con this.$emit,pero no hace falta en la template(si en el script)

Ahora si,$emit(arg1,arg2?) son dos argumentos,el primero es obligatorio y es el nombre del evento que quiero emitir,luego:

@click="$emit('selectPokemon',pokemon.id)

IMPORTANTE: lo que he hecho es crear un evento llamado 'selectPokemon' en el hijo,para que lo consuma el padre es igual,es con @event-name.Recuerda también que Vue me deja definir un evento en el hijo en camelCase y consumirlo en kebab-case:

  <PokemonOptions :pokemons="pokemonArr" @select-pokemon="checkAnswer($event)" /> <- si creo un custom event que se llama selectPokemon | select-pokemon tengo que llamarlo con @select-pokemon

  El método de momento no hace nada
  checkAnswer(event){
      console.log('Pokemon Options llamado')
    }

NOTA:el segundo argumento de $emit es opcional,porque no siempre necesitaré mandar data desde el hijo,pero en este caso si necesito mandar el pokemon.id
  @click="$emit('selectPokemon',pokemon.id)"> <- 2º argumento la data a enviar


IMPORTANTE: $event es otra palabra reservada,y simboliza todo el evento(en este caso $event es el id,pero en inputs de formulario tendré que usar $event.target.value para mandar solo el valor)

TIP: realizar esto @select-pokemon="checkAnswer($event)" y esto @select-pokemon="checkAnswer" es exactamente lo mismo,ya que el primer argumento va a pasar automáticamente entre funciones en Javascript.

NOTA: dentro del template,como ya es parte del componente,el THIS está implicito(aunque podría ponerlo)

IMPORTANTE: Vue no solo hace la traduccion de camelCase a kebab-case para eventos,también lo hacer para las props(siguiendo asi las buenas prácticas de que en el HTML deberia usarse kebab-case):
Perfectamente puedo cambiar esto:
<PokemonPicture :pokemonId="pokemon.id" :showPokemon="showPokemon" />
por esto:
<PokemonPicture :pokemon-id="pokemon.id" :show-pokemon="showPokemon" />
y rescatarlas asi en ese PokemonPicture:
 props:{
    pokemonId:{
      type: Number,
      required:true
    },
    showPokemon:{
      type: Boolean,
      required:true,
      default:false
    }
  },

No solo esto,sino que incluso en el naming del componente hace la traducción:
<pokemon-picture :pokemon-id="pokemon.id" :show-pokemon="showPokemon" />
Aunque dejarlos en PascalCase da mucho contexto al desarrollador de que es un custom component

      VIDEO 96 RESULTADO Y REINICIO DEL JUEGO

Creamos un par de propiedades más,para mostrar un mensaje,etc:
  checkAnswer(selectedId) {
      this.showPokemon = true;
      this.showAnser = true;
      this.message =
        selectedId === this.pokemon.id
          ? `Correcto, es ${this.pokemon.name}! `
          : `Oops, era ${this.pokemon.name} ...`;
    },

NOTA: puedo usar una etiqueta <template></template> igual que tengo en React los fragments o en Angular los <ng-template></ng-template> Ninguna de estas tags va a computar en el HTML,son simples agrupadores en tiempo de desarrollo.De echo se recomienda usarlos en vez de divs por esto mismo.

      VIDEO 97 DESPLEGAR APLICACION EN PRODUCCION

Para generar el build ya tenemos el comando 'build'.Recuerda que al hacer un build tanto Vue como React,Angular,etc hacen un tree shaking,eliminando todo lo que la aplicación no necesita para producción
Si ejecuto este comando veré que Vue genera la carpeta 'dist' y que le pone hashes a los archivos de css y js para que los navegadores no los cacheen(si solo tuvieran el nombre el navegador los cachea y en sucesivos builds el navegador seguiría cogiendo el primer archivo de la caché,lo cual obviamente no querriamos ) 

      SECCION 08 PRUEBAS EN POKEMON GAME

Tenemos mucho que probar,emisiones,mocks,comprobar aleatoriedad de ciertas funciones, tranmisiones de padre/hijo o hijo/padre,etc...

Puntualmente hablaremos sobre:
1- Pruebas con Axios
2- Pruebas con data aleatoria
3- Pruebas con emisiones
4- Multiples emisiones al mismo tiempo
5- stubs
6- Revisión de cambio en propiedades reactivas (data)

Esta sección contiene muchas pruebas nuevas que son necesarias en el día a día del unit test

          VIDEO 101 PRUEBAS CON AXIOS

Vamos a probar el archivo donde creamos una instancia de axios.Realmente no hay mucho que probar ahí,excepto que la baseUrl sea la esperada.
NOTA:recuerda que @/ en Vue hace referencia a la carpeta src luego:
import pokemonApi from "@/api/pokemonApi";

IMPORTANTE: fijate que salia el error 'cannot use import statement outside a module.Lo solucionamos agregando al jest.config.js:

module.exports = {
  preset: "@vue/cli-plugin-unit-jest",
  transformIgnorePatterns: ["/node_modules/(?!(axios)/)"], <-añadir
};

TIP: cuando no sepa muy bien como proceder es buena idea hacer un console.log del file,por ejemplo:
describe('PokemonApi: ', () => { 
  test('should match baseUrl', () => { 
    console.log(pokemonApi)
   })
 })

Y asi podré ver el objeto que trae el modulo.Sabiendo sus propiedades ya podemos hacer la aserción:
 expect(pokemonApi.defaults.baseURL).toBe("https://pokeapi.co/api/v2/pokemon");

    VIDEO 102 PRUEBAS EN HELPERS

FH recomienda empezar con las pruebas más fáciles,por eso empezamos por el file pokemonApi.Además,de ahora en adelante vamos a suponer que ese componente está perfectamente evaluado y funciona correctamente.
Por esto vamos a seguir por los helpers(o podriamos seguir por el App.vue,pero los helpers son aun más sencillos).

NOTA:esto es asi porque son funciones que no tienen relación con el mundo exterior,un componente siempre será más dificil que un helper,
en teoría.

Obviamente hay que importar las funciones que voy a testear.
IMPORTANTE:cuando voy a testear equality en Jest tengo que preguntarme "¿de qué tipo?".Esto es reflejado por varios métodos de aserción de igualdad: toBe,toEqual y toStrictEqual.

toBe compara la identidad referencial de los valores,mientras que toEqual hace una comparación profunda de las propiedades de los valores(usando Object.is).Por ello,toEqual es mejor para objetos(lo que incluye arrays y funciones,ojo).ToStrictEqual va un paso más allá que toEqual y también comprueba que dos objetos tengan el mismo tipo(lo cual en Typescript es muy interesante)

TIP:dos objects en Javascript siempre apuntan a zonas de memoria diferente es por ello que compararlos con toBe dará fallo(luego toBe compara los punteros a memoria).ToBe para primitivos,toEqual para objetos.

NOTA:muchas veces,al comparar arrays y objectos solo necesitaré comprobar partes de su contenido(que un objeto tenga determinada propiedad o un arreglo tenga determinado elemento...).Para ello Jest me proporciona los métodos toContain y toContainEqual.De nuevo la diferencia es la misma que toBe y toEqual

expect.arrayContaining va un paso más alla y testea si un arreglo contiene un determinado subset de elementos(usando comparación profunda además).El método necesita de otra aserción adicional,lo cual lo hace muy flexible:

expect([1,2,3]).toEqual(expect.arrayContaining([1,2]))

expect.objectContaining funciona de forma análoga(ojo que ambos esperan o un objeto o un array)

expect({a:1,b:2}).toEqual(expect.objectContaining({a:1}));

Matching any/thing: en algunos casos ni siquiera es importante el valor del subelemento sino que simplemente haga match el type:
expect(5).toEqual(expect.anything());
expect(4).toEqual(expect.any(Number)) <-recuerda meterlo en un array si es la aserción adicional de arrayContaining

Errors: Jest provee el método toThrowError para comprobar que una función lance un error.Opcionalmente,puedo pasarle un argumento para asertar el tipo del error lanzado:

function divideBy10(a){
  if(typeof a !== 'number){
    throw new Error('NaN: ' + a);
  }
  return a/10;
}

expect(() => divideBy10('a')).toThrowError() <- observa como ejecutamos la función dentro del expect y como esperamos que tire un error,lo cual hará:
expect( () => divideBy10('a')).toThrowError(/NaN/) <- también pasará

TIP: recuerda que toEqual usa Object.is por detrás.Object.is determina si dos valores son iguales(ambos son true/false | undefined | null o strings,o el mismo objeto).Esta comparación no es igual al operador '==' ni al operador '==='
Object.is('foo','foo') <- true
Object.is(window,window) <-true pues son el mismo
Object.is({},{}) <- false
Object.is('foo','bar') <- false
Object.is([],[]) <- false
Object.is(null,undefined) <- false
Object.is(null,null) <- true
Fijate que is hago obj3 = obj1 y despues Object.is(obj1,obj3) da true pues apuntan al mismo objeto.Interesante este método.

Esto es algo que tengo que tener muy claro.

VIDEO 105 PRUEBAS EN POKEMON PICTURE

Dado que en esta suite vamos a mandar props,no tiene sentido crear el wrapper en el beforeEach y dejarlo estático.Habrá que usar el segundo argumento del método shallowMount(cmp,options:{}):

  test("1- should match snapshot", () => {
    const wrapper = shallowMount(PokemonPicture, {
      props: {
        pokemonId: 1,
        showPokemon: false,
      },
    });
    expect(wrapper.html()).toMatchSnapshot();
  });

NOTA: fijate que si no mando las props me da un warning,pero pasaría la prueba.
TIP: puedo ver que tengo varios métodos como img.attributes() | img.classes() text(),exists(),etc.Dado que queremos ver si el src está cogiendo el 100 como pokemonId es tan sencillo como:
expect(img.attributes('src)).toBe("xxxx/100.svg)
y lo mismo para clases o wrapper.props()
Desde luego tiene buena pinta el testing con Vue.Debería de tratar de ver como hacer todo esto en React(acceder a los atributos,props y las clases)
IMPORTANTE: en React tengo toHaveClass y toHaveAttribute,ambos de la libreria react-testing-library, para hacer lo mismo:

expect(getByText("Send")).toHaveAttribute(
    "href",
    "mailto:example@example.com?subject=Hello"
  );
* Parece que toHave devuelve todos,puedo acceder a uno en concreto con getAttribute
expect(getByText("Send").getAttribute("href")).toMatch(
    /mailto:example@example.com/
  );

Volviendo al video puedo hacer aserciones de esta forma:
    expect(img.attributes("src")).toBe(
      "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/dream-world/100.svg",
    );

    expect(img.classes()).toContain("hidden-pokemon");
    // otra forma sería asi
    expect(img.classes("hidden-pokemon")).toBe(true);

Genial.Muy prehistoric esta libreria,asinto.

VIDEO 107 PRUEBAS EN POKEMON OPTIONS

Este componente es un tanto especial,ya que tenemos que asegurarnos de que al hacer click en un <li></li> emitimos un evento(además de asegurarnos que emite el valor que debe emitir)
Recuerda también que es buen momento para crear la carpeta mocks con los pokemons,pues los estamos necesitando en varios files ya(de momento metemos la carpeta en unit/mocks).Fijate que en nuestro proyecto quizás hubiera sido buena idea haber creado más carpetas

NOTA: fijate que tengo también toMatchInlineSnapshot,aunque esto me va a traer la template a la prueba,en vez de a una carpeta aparte.Puede que no sea lo que quiera cuando sean componentes grandes.Además,el html es el mismo,parece mejor idea tener las snapshots recogidas en una carpeta y no embebidas en el test

  VIDEO 108 TESTING DE EMISIONES DE EVENTOS

 En Vue es incluso demasiado fácil ver que un evento se ha emitido(ojo,son eventos que hayan sido emitidos con $emit).Puedo acceder a los eventos emitidos con wrapper.emitted():
   
   const wrapper = shallowMount(PokemonOptions, {
      props: {
        pokemons: mockPokemons,
        hasSelected: false,
      },
    });
    const [pk1, pk2, pk3, pk4] = wrapper.findAll("li");
    pk2.trigger("click");
    console.log(wrapper.emitted()) 

* Fijate que lo que hace es emitir un objeto con eventos como keys y que los valores emitidos van en un arreglo de arreglos.
console.log
 { selectPokemon: [ [ 2 ] ], click: [ [ [MouseEvent] ] ] }

 Recuerda también que es obligación del desarrollador refactorizar código.Estos findAll son ideales para usar programación funcional:
   
   const liTags = wrapper.findAll("li");
    liTags.forEach((li, index) => {
      li.trigger("click");
      expect(wrapper.emitted("selectPokemon")[index][0]).toBe(mockPokemons[index].id);
    });

VIDEO 109 PRUEBAS EN POKEMON PAGE

PokemonPage es en teoría un poco más complejo ya que tiene la llamada a varios componentes hijos en él.Sin embargo,debemos tener en cuenta que ya hemos echo pruebas sobre esos componentes(o las iriamos a hacer),luego debo partir de la premisa de que funcionan correctamente.
NOTA: esta es la primera vez que tenemos un componente al que shallowMount se le pudiera quedar corto y necesitemos de mount:

import { shallowMount,mount } from "@vue/test-utils";


TIP: pudiera parecer que crear un snapshot puede ser una prueba útil pero no lo es:
  test("should match with its snapshot", () => {
    expect(wrapper.html()).toMatchInlineSnapshot(
      `<h1>Espere por favor...</h1>`
    );
  });

Obviamente si le pasaramos un pokemon y entrara por el v-else si que tendría sentido la snapshot

Bien,una prueba que si es interesante es comprobar que en el mounted se llama al mixPokemonArray.Fijate que hay que espiar el objeto PokemonPage.methods <- pero en su propiedad methods:

test("should call mixPokemonArray method when mounted", () => {
    const mixPokemonSpy = jest.spyOn(PokemonPage.methods, "mixPokemonArray");
    expect(mixPokemonSpy).toHaveBeenCalledTimes(1)    
  });

  IMPORTANTE: todo espia debe ser definido antes de montar el componente.Esta prueba va a fallar(crear si que crea el espia,pero ya se disparó todo en el componente).Es decir que antes de crear el wrapper hay que crear el espia,pues al crear el wrapper se dispara el mounted:

   beforeEach(() => {
    mixPokemonSpy = jest.spyOn(PokemonPage.methods, "mixPokemonArray");
    wrapper = shallowMount(PokemonPage);
    jest.clearAllMocks;
  });

La otra solución,y para que no cree un espia en cada test,lo cual la hace mejor solución es volver a llamar al shallowMount,que disparará el mounted,etc:

 test("should call mixPokemonArray method when mounted", () => {
    const mixPokemonSpy = jest.spyOn(PokemonPage.methods, "mixPokemonArray");
    shallowMount(PokemonPage); <- remontamos el cmp
    expect(mixPokemonSpy).toHaveBeenCalledTimes(1);
  });

  Ambas arreglan el problema,la segunda pudiera ser un poco más eficiente.
  NOTA:además,si creo un espia por cada test puedo tener problemas,es recomendable la segunda opción,diria yo.
  Todo esto es terriblemente interesante,asinto.
  TIP: también se puede espiar al wrapper.vm,espiar a PokemonPage.methods 

    VIDEO 110 SNAPSHOT CON DATA Y STUBS

Ya hemos visto que el snapshot no tiene mucho sentido,sin embargo,si que lo tendría si pudieramos tener toda la información y pudieramos esperar a sacar ese snapshot.

TIP: debo ser muy consciente de que puedo montar cuantas veces quiera el componente(es decir,que puedo llamar al shallowMount varias veces).Incluso puedo hacer unas pruebas con shallowMount y otras con montado profundo usando mount

Volviendo al test,para entrar por el v-else tengo que tener un pokemon,pero no sólo eso,pues al entrar por el v-else se van a montar los otros dos componentes y necesitarian toda la data.Es decir que tengo que recrear todo lo que tengo en data,prácticamente,para que funcione todo bien.Perfectamente se puede hacer esto en Vue.
TIP:fijate que no son props,es la data:

    const wrapper = shallowMount(PokemonPage, {
      data() {
        return {
          pokemonArr: mockPokemons,
          pokemon: mockPokemons[1],
          showPokemon: false,
          showAnswer: false,
          message: "",
          hasSelected: false,
        };
      },
    });

*Si ahora le saco la snapshot veré esto:
    expect(wrapper.html()).toMatchInlineSnapshot(`
      <div>
        <h1>¿Quién es este pokémon?</h1>
        <pokemon-picture-stub pokemonid="2" showpokemon="false"></pokemon-picture-stub>
        <pokemon-options-stub pokemons="[object Object],[object Object],[object Object],[object Object]" hasselected="false"></pokemon-options-stub>
        <!--v-if-->
      </div>
    `);
  });

* ¿Pero que es ese <pokemon-picture-stub>?¿Y porqué falla la prueba?Esto es porque estamos usando shallowMount.ShallowMount no va a recrear los subcomponentes totalmente,sino que crea esa etiqueta que realmente no hace nada.
Obviamente si uso mount se montarán los hijos,pero montarlos implicará que se disparen sus ciclos de vida,podría causar re-renderizados,etc,asi que hay que tener claro que mount es más costoso y no siempre es necesario

Si usamos mount veriamos esto(ya no tenemos los stubs sino que renderiza los subcomponentes):

   expect(wrapper.html()).toMatchInlineSnapshot(`
      <div>
        <h1>¿Quién es este pokémon?</h1>
        <div class="pokemon-container"><img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/dream-world/2.svg" class="hidden-pokemon" alt="pokemon"></div>
        <div class="options-container">
          <ul>
            <li>Bulbasaur</li>
            <li>Ivysaur</li>
            <li>Venusaur</li>
            <li>Charmander</li>
          </ul>
        </div>
        <!--v-if-->
      </div>
    `);

Hasta donde sea posible se recomienda usar shallowMount,pero siempre que se necesite de los subcomponentes hay que usar mount
TIP:incluso llamando a mount puedo volver a shallow:
const wrapper = mount(ComplexComponent,{
  shallow: true // <- ya no es un mount
})

VIDEO 111 TAREA. PRUEBA DE QUE LOS SUBCOMPONENTES EXISTAN

TIP: la libreria provee el método findComponent para buscar subcomponentes en un cmp.Ojo,si los llamo sin usar el objeto de opciones  que hay que importar los subcomponentes también:

import PokemonPicture from "@/components/PokemonPicture";

  const PokemonPictureCmp = wrapper.findComponent(PokemonPicture)
  expect(PokemonPictureCmp.exists()).toBe(true)
  console.log(PokemonPictureCmp.props())

  O también puedo no importarlo y usar
  const PokemonPictureCmp = wrapper.findComponent({name: 'PokemonPicture'})
  Ambas son correctas

Fijate que FH lo hizo con shallowMount y buscando por la tag,despues comprobando con attributes,y que al usar mount estoy obligado a usar findComponent.
Sin embargo,puedo usar findComponent con shallowMount también, y la prueba funciona igual.Parece la mejor opción,aunque claro que buscar por tags y despues sus attributes también es totalmente válida

  const wrapper = mount(PokemonPage, {
      data() {
        return {
          pokemonArr: mockPokemons,
          pokemon: mockPokemons[1], //id 2
          showPokemon: false,
          showAnswer: false,
          message: "",
          hasSelected: false,
        };
      },
    });
    
    // existen los subcomponentes
    const PokemonPictureCmp = wrapper.findComponent(PokemonPicture);
    const PokemonOptionsCmp = wrapper.findComponent(PokemonOptions);
    expect(PokemonPictureCmp.exists()).toBe(true);
    expect(PokemonOptionsCmp.exists()).toBe(true);
    
    // Picture reciba la prop pokemonId con valor correcto
    expect(PokemonPictureCmp.props("pokemonId")).toBe(mockPokemons[1].id);

    // Options debe tener la prop pokemons
    expect(PokemonOptionsCmp.props("pokemons")).toBeDefined();
    // assert extra
    expect(PokemonOptionsCmp.props("pokemons")).toEqual(mockPokemons);

IMPORTANTE: puede que no quiera dejar el espia con la funcionalidad intacta,dado que un espia es un mock puedo hacer que retorne cualquier cosa y asi no dispara la funcionalidad original.Además,en vez de usar jest.spyOn(object,methodName) puedo usar object[methodName] = jest.fn(). Ejemplo:

const newGameSpy = jest.spyOn(PokemonPage.methods,'newGame')
const newGameSpy = jest.spyOn(PokemonPage.methods,'newGame').mockImplementation(() => true)
PokemonPage.methods["newGame"] = jest.fn();
* recuerda que puedo hacer lo mismo usando wrapper.vm tras montar el cmp
const newGameSpy = jest.spyOn(wrapper.vm,'newGame') <- tras el shallowMount
wrapper.vm['newGame'] = jest.fn() <-obviamente tras estar definido wrapper.
Muy interesante todo esto,asinto

VIDEO 112 PRUEBAS EN LAS PROPIEDADES REACTIVAS DEL COMPONENTE

Para realizar esto fijate que puedo llamar literalmente al método que quiera usando wrapper.vm.methodName:

   const wrapper = mount(PokemonPage, {
       data() {
         return {
           pokemonArr: mockPokemons,
           pokemon: mockPokemons[1], //id 2
           showPokemon: false,
           showAnswer: false,
           message: "",
           hasSelected: false,
         };
       },
     });
    //  puedo llamar a un método mediante wrapper.vm.methodName()
    wrapper.vm.checkAnswer(2); <- llamada física al método

NOTA: cuando haga alguna modificación a alguna de las propiedades reactivas,y ese cambio deba hacer alguna modificación en el DOM(más bien sería un VirtualDOM,pues estamos en testing) recuerda que tengo que usar asincronia:
 await wrapper.vm.checkAnswer(2); <-
 expect(wrapper.find("h2").exists()).toBe(true);

 Fijate que esto es extrapolable a cualquier framework.Usar await va a disparar cualquier watcher que tuviera,los ciclos de vida correspondientes,etc,por ello hay que esperar(porque cambia el DOM,recuerda).

 IMPORTANTE:recuerda que en wrapper.vm tengo todas las propiedades reactivas que he creado:
  await wrapper.vm.checkAnswer(2); //recuerda que el 2 va a coincidir
  expect(wrapper.find("h2").exists()).toBe(true); <- este cambio en el DOM obliga a asincronia
  expect(wrapper.vm.showPokemon).toBe(true) <- propiedad reactiva

    SECCION 09 OPTIONS-API -RUTAS CON VUE ROUTER Y LIFECYCLES EN VUE

Recordemos que el routing y el concepto de SPA va intrinsicamente ligado.Las aplicaciones de Angular,Vue o React suelen ser SPA que navegan (o simulan navegar) a otras rutas.Veremos el routing en Vue,queryParameters,segmentos de Url,... :
 En esta sección aprenderemos profundamente a utilizar y configurar el Vue Router, el cual permite crear una navegación entre componentes, puntualmente veremos:

1- Vue Router
2- Navegación por:
   Path
   Nombre
   Programáticamente
   Estáticamente
3- Guards
   Síncronos
   Asíncronos
4- 404 Page
5- Rutas hijas
6- Diferentes diseños entre router views
7- Argumentos por URL (Query parameters)
8- Segmentos por URL
9- Lifecycle hooks
    Nota, con el Options API, luego hablaremos del composition API en otras secciones.
    Llamar cada lifecycle hooks y los más comunes

Es una sección grande en la cual quiero enfocarme en que dominemos bien el Vue Router para aplicaciones futuras


 

        SECCION 10 INTRODUCCIÓN A VUEX

Vuex es similar a Redux en React,es su gestor de estado,es decir,essu solución para gestionar el paso de información entre componentes alejados en el árbol.
Es una sección fundamental.
Vuex es su gestor de estado más usado en Vue.Conceptos generales:

State:objeto reactivo con el estado actual/inicial
acciones: acciones asincronas que modifican el state
mutations: una acción siempre llama a una mutación,y es ésta la que cambia el state realmente
getters: los getters son una forma pre-procesada de obtener información del store rápidamente(custom selectors??)

NOTA:en el momento en que necesite trabajar con VueX en una aplicación debo trabajar en base a módulos(extrapolable a React o Angular)

Esta sección esta dedicada a tener una introducción a Vuex, como gestor de estado global de nuestra aplicación, puntualmente veremos:

1- ¿Qué es Vuex?
2- ¿Qué problema resuelve Vuex?
3- Actions
4- Getters
5- Mutations
6- State
7- Módulos
8- Segmentación
9- Vuex DevTools

      VIDEO 140 INTRODUCCION A VUEX

La idea de VueX es crear un store,para que cualquier componente pueda consumirlo y/o actualizarlo.Esto reduce mucho la complejidad que si fuera todo por props,etc.Recuerda que el state de ese store es totalmente reactivo,cualquier cambio en él disparará cambios en las vies
El flujo de información es igual que en Redux,Flux o la arquitectura Elm(en resumen, cualquier gestor de estado),donde las acciones notifican al estado,el cual notifica a la vista.
VueX está diseñado especificamente para trabajar con Vue.Las vistas harán dispatch de una acción,esa acción hace el commit de una mutation.Las mutaciones son sincronas(no pueden ser asincronas).Se llaman asi porque es codigo que al final va a terminar mutando nuestro state.
No necesariamente hay que pasar por una accion para disparar una mutation.Se puede llamar al commit directamente desde una view.
Como el state es reactivo,cualquier view que consuma ese state será actualizado.
NOTA:las acciones pueden ser tanto asincronas como sincronas,luego siempre tendré que usar una acción cuando haya asincronia.Las mutaciones solo pueden ser síncronas.
Una acción tampoco puede modificar directamente el state,siempre debe pasar por el commit de una mutación.

Conceptos generales:

State: similar a la data(),es reactivo
Getters: similares a las propiedades computadas
Mutations: funciones que pueden modificar el state(no tienen porque modificarlo)
Actions: funciones que pueden ser asíncronas y pueden llamar a mutations(ojo con ambos pueden)
Modules: basicamente es un agrupador en el que puedo tener state,getters,mutations,actions e incluso otros modules(entiendo que es un slice del store)
Un store es basicamente un agrupador de modulos,pues.

Debo usar VueX cuando la app sea minimamente compleja y lo necesite.No es nada dificil de implementar.

VIDEO 142 INSTALACION MANUAL DE VUEX

NOTA: VueX 4 en adelante da soporte tanto a la Options API como a la compositions API.Fernando provee el siguiente enlace con la docu:
https://vuex.vuejs.org/installation.html#direct-download-cdn

Alli puedo ver que puedo incluso usar una CDN,pero lo haremos con yarn:
npm install vuex@next --save <- puedo ver que me instaló  "vuex": "^4.0.2" 

Una vez instalada la lib puedo seguir por aqui:
https://vuex.vuejs.org/guide/

TIP: recuerda que un store es un contenedor para el state de la aplicación.Recuerda que el state es un simple mega-objeto,pero que es reactivo y al que no se le puede mutar directamente,hay que usar comitted mutations.Creamos un store supersimple de momento:

En /src/store/index.js:

import { createStore } from 'vuex' 
const store = createStore({
  // estado inicial
  state:{
    count : 1
  }
})

export default store;

El main.js lo tiene que consumir con .use(slice):
En el main.js:
import store from './store';

createApp(App)
  .use(store)
  .mount('#app');

Si ahora voy a las devTools debería ver ese state con el counter.

            VIDEO 143 LEER EL STATE REACTIVO


De nuevo y por última vez recuerda que el state es un objeto reactivo,cualquier cambio en él va a notificar a cualquier vista que lo consuma

Fijate que puedo acceder directamente al store con $store(aqui si me parece que gana a React en accesibilidad al state)
<template >
  <h1>Counter - Vuex </h1>
  <h2>Direct access: {{ $store.state.count }}</h2>
</template>

Incluso desde Javascript:
<template>
  <h1>Counter - Vuex</h1>
  <h2>Direct access: {{ $store.state.count }}</h2>
  <h2>Computed {{ countComputed }}</h2>
  <h2>ShitComputed {{ anotherShitComputed }}</h2>
</template>

<script>
export default {
  computed: {
    countComputed() {
      return this.$store.state.count;
    },
    anotherShitComputed() {
      return this.countComputed;
    },
  },
};
</script>

Sin embargo,no es lo normal acceder tan directamente al state.Lo normal es usar un mapeo previo del que sacamos lo que necesitemos:

<script>
import { mapState } from "vuex";

console.log(mapState(["count",'lastMutation']));

export default {
  computed: {
    countComputed() {
      return this.$store.state.count;
    },
    anotherShitComputed() {
      return this.countComputed;
    },
    ...mapState(["count"]),
  },
};
</script>

Para ello vuex me ofrece los métodos mapState ó mapMutations ó mapActions,etc y no tener que usar $store.state.XXX.
NOTA: hay varias maneras de acceder a una propiedad del state:
1 => con mapState(['propName1','propName2'])
2 => con mapState({counter: state => state.count }) <- útil para renombrar una prop del state


Obviamente puedo sacar las que quiera:
export default {
  computed: {
    countComputed() {
      return this.$store.state.count;
    },
    anotherShitComputed() {
      return this.countComputed;
    },
    ...mapState({
      counter: state => state.count,
      lastMutation: state => state.lastMutation
    }),
  },
};

                  VIDEO 144 MUTATIONS

Recuerda que el state en producción no puedo cambiarlo desde las devTools,solo en desarrollo.Pero aunque podemos hacerlo desde las devTools realmente se hace desde código,commiteando una mutation.

Para crear una mutation es igual que si fuera methods o computed en un componente,pero en el createStore:
const store = createStore({
  // estado inicial
  state:{
    count : 1,
    lastMutation: 'none'
  },
  mutations:{
    increment(state){
      state.count++;
      state.lastMutation = 'increment'
    }
  }
})
Fijate que las mutations no tienen acceso por defecto al state y lo tengo que pasar como argumento en cada mutation.

Recuerda también que no puedo mutar el state,y que las mutations se commiteaban luego tengo que acceder desde una vista con this.$store.commit('name of the mutation declared'):

  methods:{
    increment(){
      this.$store.commit('increment'); // ojo es el nombre de la mutación
    }
  },
Y si necesitara argumentos desde el commit hay que mandarlos(obviamente los recibo como segundo argumento):
En el store:
 mutations: {
    increment(state) {
      state.count++;
      state.lastMutation = "increment";
    },
    incrementBy(state,value) {
      state.count += value;
      state.lastMutation = "incrementBy";
    },
  },

  Y desde la view:
   incrementBy(){
      this.$store.commit('incrementBy',5); // ojo es el nombre de la mutación
    },

VIDEO 145 ACTIONS

Al igual que tengo el state y las mutations en el createStore tengo la propiedad actions.Usualmente las actions son asincronas,por ejemplo comprobar algo con una peticion http y ya despues se hace el commit de una mutation(con lo que parece que la asincronia serán dos funciones en Vue ??)

async function getRandomInt(){
 return await new Promise( resolve => { <- recuerda que el return ya es asincrono,me hace de await tmb
    const rndInt = Math.random().toFixed(2)*100;
    setTimeout(() => resolve(rndInt), 1000);
    
  })
}

Bien,ahora tiene que quedar claro que las acciones no pueden mutar el state,y por ello no necesitan acceder a él.Si quisieran mutarlo tienen que hacerlo mediante una mutation,y por ello si tienen acceso al contexto,que es el module actual o el propio store,si no hubiera modulos:

 actions: {
    // en el caso de una acción lo que recibe como primer argumento es un context,y no un state.El context tiene la referencia sobre el store(o módulo en el que me encontrara,en este caso es el store ya que no hay slices)
    async incrementRandomInt(context){
      // recuerda que una acción no puede mutar el state,eso solo lo puede hacer una mutation
      // state.loading = true <- no se puede con una action

      // DESDE UNA ACTION TENGO QUE USAR EL CONTEXT PARA ACCEDER A UNA MUTATION QUE CAMBIE EL STATE
      context.commit('changeLoading',true)
      const randomInt = await getRandomInt()
      context.commit('incrementBy',randomInt)
      context.commit('changeLoading',false)
      
    }
  }

  Y para llamar desde la view a una action de momento lo podemos hacer mediante this.$store.dispatch('action name',args?).-Fijate que las acciones se disparan y las mutations se commitean.
  <button @click="incrementRandomInt">Random</button>

    incrementRandomInt(){
      this.$store.dispatch('incrementRandomInt')
    }

TIP:fijate que llamar a una función para que llame al dispatch realmente podría llamar al dispatch directamente desde la template.Veremos como hacerlo en breve

            VIDEO 146 MAP ACTIONS

Actually it doesn't have any sense having a method that inmediately returns another.Podemos usar el método mapActions de manera similar al mapState(aunque uno va en los methods y otro en las computed props):

import { mapState, mapActions } from "vuex";

export default {
  methods:{
    increment(){
      this.$store.commit('increment'); // ojo es el nombre de la mutación
    },
    incrementBy(){
      this.$store.commit('incrementBy',5); // ojo es el nombre de la mutación
    },
    ...mapActions(['incrementRandomInt'])
  },
  computed: {
    countComputed() {
      return this.$store.state.count;
    },
    anotherShitComputed() {
      return this.countComputed;
    },
    ...mapState({
      counter: state => state.count,
      lastMutation: state => state.lastMutation
    }),
  },

NOTA: también puedo usar esta forma para renombrar(de echo tengo que usarla para las actions):
 ...mapActions({
      randomInt: 'incrementRandomInt'
    })
en el mapState puedo hacer algo similar(aqui si tengo dos opciones):
...mapState({
  counter: 'counter' 
})      

IMPORTANTE: también de manera similar al mapState,cada action que me traiga la puedo usar en cualquier parte de ese componente ya:
 methods:{
    increment(){
      this.$store.commit('increment'); // ojo es el nombre de la mutación
    },
    incrementBy(){
      this.randomInt() <- LA PUEDO USAR AQUI PUES YA TENGO VISION SOBRE ESA ACCION DESDE QUE LA TRAJE CON EL MAPACTIONS
      this.$store.commit('incrementBy',5); // ojo es el nombre de la mutación
    },
    ...mapActions({randomInt: 'incrementRandomInt'})

        VIDEO 147 BLOQUEAR BOTON MIENTRAS UNA ACCIÓN TRABAJA

Tarea muy sencilla,crear una propiedad isLoading y en la action llamar a una mutation que la cambie,despues sacarla con el mapState y usarla en el disabled con un v-bind:

 async incrementRandomInt({commit}) {  // mejor desestructurar el context,asinto
      // DESDE UNA ACTION TENGO QUE USAR EL CONTEXT PARA ACCEDER A UNA MUTATION QUE CAMBIE EL STATE
      commit("setLoading", true);
      const randomInt = await getRandomInt();
      commit("incrementBy", randomInt);
      commit("setLoading", false);
    }

En la template acceder al state
<button @click="randomInt" :disabled="isLoading">Random</button>

        VIDEO 148  GETTERS

Ya hemos visto en el método createStore las propiedades state(para definir el state),mutations(para mutarlo sincronamente) y las actions(para poder usar asincronia,recuerda que tienen acceso al context y pueden commitear mutations si es necesario).Vamos a ver otra propiedad más,los getters.

Los getters pueden ser llamados en cualquier parte de la aplicación,son muy parecidos a una computed property(diria que son como un acceso rápido a una parte del state/módulo),lo cual muchas veces puede ser más eficiente que traer todo el slice concreto:

  actions: {
    async incrementRandomInt({commit}) {  // mejor desestructurar el context,asinto
      commit("setLoading", true);
      const randomInt = await getRandomInt();
      commit("incrementBy", randomInt);
      commit("setLoading", false);
    },
  },
  getters:{
    squareCount(state){
      return state.count * state.count
    }
Fijate que tienen acceso al state,por motivos obvios,ya que son un acceso rápido al mismo(incluso pueden valer para hacer alguna operación sencilla)
NOTA:obviamente este getter se va a actualizar cuando cambie a lo que apunta(en este caso state.count) ya que son totalmente reactivos.

Para acceder desde la template Vuex nos ofrece el mapGetters,aunque también podemos acceder mediante $store.getters:
 <h2>Direct getter:{{ $store.getters.squareCount}} </h2>

      VIDEO 149 MODULES - INTRO

Casi nunca voy a usar un único estado.Normalmente será una unión de varios slices lo que conformará el store.No tiene sentido tener un único store asi:
state :{
  counter,
  products: [],
  selectedProduct:{},
  auth:{name: 'Fernando},
  isLoading:false
} 
Hay demasiada mezcla de conceptos/lógica de negocio.La idea es separar en módulos el state de la app según agrupaciones lógicas.

const store = createStore({
  modules: {
    account: {
      namespaced: true,
      state: () => ({ ... }), // recuerda que state necesita ser reactivo y tiene que ser una callback su valor(parece que debe ir debajo de namespaced: true también)
      getters: {
        isAdmin () { ... } // -> getters['account/isAdmin']
      },
      actions: {
        login () { ... } // -> dispatch('account/login')
      },
      mutations: {
        login () { ... } // -> commit('account/login')
      },

Recuerda que usar namespaced a true es casi una obligación(y que y).Poner namespaced a true encapsulará ese módulo.

Fijate también que por defecto las actions,los getters y mutations son registradas bajo el namespace global pero ahora ya no funcionan.Lo arreglaremos en el siguiente video

VIDEO 150 ACTIONS-GETTERS-MUTATIONS-STATE ACCESO DESDE UN MODULO

Simplemente tenemos que ajustar las rutas,ya que hemos creado una abstracción.

UNO: para el acceso directo al state tengo que usar $store.state.<modulo>.count:
* Luego tengo que cambiar cualquier $store.state
 <h2>Direct access: {{ $store.state.counter.count }}</h2>

 DOS: lo mismo para cualquier otra zona,como la computed:

 computed: {
    countComputed() {
      return this.$store.state.counter.count;
    },
    anotherShitComputed() {
      return this.countComputed;
    },
    ...mapState({
      counter: state => state.counter.count,
      lastMutation: state => state.counter.lastMutation,
      isLoading: state => state.counter.isLoading
    }),
  },

TRES: para las mutations hay que anteponer el modulo:
  methods:{
    increment(){
      // ojo es 'modulo/mutation
      this.$store.commit('counter/increment'); 
    },
    incrementBy(){
      this.$store.commit('counter/incrementBy',5); 
    },

CUATRO: lo mismo para las actions:
  ...mapActions({
      randomInt: 'counter/incrementRandomInt'
    })

Fijate que si usará la forma con el array ahora tendrá dos argumentos,el primero es el modulo:
mapActions('counter',['incrementRandomInt'])
Dependerá de la sintaxis

Lo mismo con el mapState si hubiera usado la notación con el array:
mapState('counter',['counter','lastMutation','isLoading])

Fijate que en este punto queda bien claro que es mucho más sencillo usar mapState o mapActions con arrays al trabajar con módulos,solo hay que poner un argumento.Es decir,no usar esto:
    
    ...mapState({
      counter: state => state.counter.count,
      lastMutation: state => state.counter.lastMutation,
      isLoading: state => state.counter.isLoading
    }),

QUINTO: el acceso directo al getter también cambia e inclusive hay que usar otra sintaxis:
 <h2>Direct getter:{{ $store.getters['counter/squareCount']}} </h2>

        VIDEO 151 SEPARAR UN MÓDULO EN ARCHIVOS INDEPENDIENTES

Queremos separar el state,las acciones,las mutaciones,los getters de nuestro módulo cada una a un archivo independiente.Creamos pues un archivo para cada prop en esa carpeta.

En el state.js exporto la funcion que hacia el state reactivo:
export default () => ({
    count: 1,
    lastMutation: "none",
    isLoading: false,
    lastRandomInt: 0,
  });

En el mutations.js ahora tendré que exportara cada función(además ahora son funciones,antes eran métodos):
export function increment(state) {
  state.count++;
  state.lastMutation = "increment";
}
export function incrementBy(state, value) {
  state.count += value;
  state.lastMutation = "incrementBy";
  state.lastRandomInt = value;
}
export function setLoading(state, value) {
  state.isLoading = value;
  state.lastMutation = "setLoading";
}

Lo mismo paa las acciones:
En el actions.js:
import getRandomInt from "@/helpers/getRandomInt";

export async function incrementRandomInt({ commit }) {
  commit("setLoading", true);
  const randomInt = await getRandomInt();
  commit("incrementBy", randomInt);
  commit("setLoading", false);
}

IMPORTANTE: estos archivos que exportan funciones tienen que exportar cada una por separado,y por ello puedo importarlas despues con *:
import * as mutations from "./mutations";
y despues pasarlas asi:
mutations:mutations  <- lo cual se puede resumir desde ECMA2016

Lo mismo para los getters.Al final me quedará algo asi:

const counterStore = {
  namespaced:true,
  state,
  mutations,
  actions,
  getters
}
export default counterStore;

Desde luego queda muy limpio.Teniendo en cuenta que no siempre tendré los getters puede ser interesante perder cohesión ya que ganar esta modularidad parece buen intercambio
Obviamente queda mucho más fácil dar mantenimiento a cada una de estas piezas,o escalar funcionalidad,etc.

      SECCION 11 JOURNAL APP - OPTIONS API + VUEX

Vamos a crear una app que maneje la entrada de registros a un diario.Usaremos getters con funciones.Crearemos tokens,peticiones HTTP,el backend,etc.Serán varias secciones.

En esta sección crearemos y configuraremos una aplicación para llevar registro de un diario, todo trabajado con OptionsAPI y Vuex, puntualmente haremos lo siguiente:

1- Configuración de módulos en Vuex
2- Configurar un backend para realizar peticiones http
3- Getters con argumentos
4- Controlar el state global y modular
5- Diferentes rutas principales y rutas hijas
6- Rutas con diferentes templates o plantillas
Y más

En esta sección aún no haremos nuestro CRUD, pero lo dejaremos todo preparado para la siguiente, pero todo lo que veremos aquí será de mucha utilidad para ustedes

        VIDEO 155 -156 -157 INICIO PROYECTO - CONFIGURAR BOOTSTRAP -AÑADIR SASS

Docu: https://getbootstrap.com/

Creamos una nueva app con 'vue create <app-name>'.Elegimos el router y el linter,aparte de babel.
Fijate que FH nos muestra un ejemplo en el que se trae Bootstrap mediante un CDN,pero al hacerlo asi no podemos modificar el SASS(no pudiendo sobreescribir ningun color,etc).Al instalarlo podemos sobreescribir la configuración por defecto(fijate que con una CDN no podria hacer nada más que tener el bootstrap por defecto)
>yarn addd bootstrap

Aun falta importar la libreria(fijate que vamos a crear un styles/styles.scss con el siguiente import):
@import 'node_modules/bootstrap/scss/bootstrap.scss';

Ya en el main.js importamos ese archivo

import "./styles/styles.scss";
createApp(App).use(router).mount("#app");

Pero fijate que nos pide sass-loader(aparte del core sass).No tiene sentido que no sean para desarrollo only:
>yarn add -D sass-loader@10 sass

Esta es la forma a proceder cuando quiero personalizar Bootstrap más allá de su configuración por defecto.

Para cambiar los colores antes del import(tiene que ser antes) puede remapear los valores de la variable $theme-colors:
$theme-colors: (
  "primary": #2c3e50,
  "secondary": #1d6042,
  "success": #198754,
  "info": #0dcaf0,
  "warning": #ffc107,
  "danger": #dc3545,
  "light": #f8f9fa,
  "dark": #343a40,
);
@import "node_modules/bootstrap/scss/bootstrap.scss";

      VIDEO 158 ESTRUCTURA MODULAR

En cualquier aplicación mediana o grande la estructura de tener todo colgando de src se queda un poco pequeña(estructura de directorios).Podria terminar con decenas o cientos de componentes en el directorio componentes(que además no tendrán relación de negocio entre muchos de ellos).En este tipo de aplicaciones hay que seguir una estructura modular.
Tener una estructura modular incluso me podria valer para importar modulos a otros proyectos.Obviamente,es la estructura a seguir(debo tratar de implementarla siempre)
Para implementar este tipo de estructura simplemente creo la carpeta modules colgando de src(src/modules).Despues de momento creamos dos modulos auth y daybook(src/modules/auth y src/modules/daybook).Dentro de cada uno ya puedo crear sus componentes,rutas,views,layouts,api,helpers,etc.

Bien,implementemos las rutas hijas,va a ser muy fácil.Dado que una ruta padre con hijas luciría asi:
 {
    path: '/',
    name: 'home',
    component: HomeView, <- o lo traigo asi o con lazyLoad,pero viene un Componente
    children:[]
  },
lo que vamos a hacer es definir en el router/index.js padre solo la propiedad path y el resto en cada router/index.js de cada modulo:

En el mainRouter:

import dayBookRoutes from '../modules/daybook/router'
   ...rutas principales....
  {
    path: '/daybook',
    ...dayBookRoutes <- spread de la export default
  }
  En el archivo de rutas de cada modulo(en el que quiera,claro):

  export default {
  name: "daybook",
  component: () => import(/* webpackChunkName: "daybook" */ "@/modules/daybook/layouts/DayBookLayout.vue"),
  children: [],
};
Faltaría el <router-view> para las rutas hijas

    VIDEO 159 ESTRUCTURA DEL DAYBOOK LAYOUT

Maquetación pura y dura.Fijate donde vamos a renderizar las rutas hijas( en la col de 8 restante):

En el DaybookLayout.vue:
<template>
  <Navbar />
  <div class="d-flex">
    <div class="col-4">
      <EntryList />
    </div>
    <div class="col">
      <router-view></router-view>
    </div>
  </div>
</template>

<script>
import { defineAsyncComponent } from "vue";

export default {
  components: {
    Navbar: defineAsyncComponent(() => import("../components/Navbar.vue")),
    EntryList: defineAsyncComponent(() => import("../components/EntryList.vue")),
  },
};
El EntryList será la lista de entradas(una entrada será el cmp Entry)
Recuerda agregar a las rules "vue/multi-word-component-names": "off" si sale el error de multi-word needed
  
      VIDEO 160 COMPONENTES ENTRY-LIST Y ENTRY

NOTA: fijate que cada <template></template> debe tener al menos una etiqueta,no puede haber componentes vacíos en Vue.
El componente EntryList barre con un v-for la coleccion de items.También tiene un Input arriba,para buscar una entrada:
<Entry v-for="entry in 10" :key="entry"></Entry> <- recuerda que estos prehistorics usan un for in y que en Vue no uso 'let index'.
El componente EntryList es simplemente la entrada

    VIDEO 161 COMPONENTE FAB Y NO-ENTRY-SELECTED

Creamos un boton y lo ponemos con position fixed a la dcha y abajo.El No entry es para cuando no haya una entrada seleccionada.Creamos su ruta.

    VIDEO 162 ENTRYVIEW

Creamos la View y su ruta(es daybook/:id).Seguir la maquetación.

    VIDEO 163 TAREA CREAR PROP ICON PARA EL FAB

Este video es interesante,ya que mediante la prop vamos a mostrar una clase u otra.Yo usé una propiedad computada para gestionar toda la clase,pero hay más formas:

 <button class="btn btn-primary">
    <i :class="parseClass"></i>
  </button>
</template>

<script>

export default {
  props:{
    icon:{
      type: String,
      default: "fa-plus"
    }
  },
  computed:{
    parseClass(){
      return "fa fa-2x " + this.icon
    }
  }  
}

Otra forma muy interesante es dejar con el atributo 'class' lo que sea común y despues usar un v-bind con :class.Vue va a juntar todo en la misma clase.De estar forma me quitaba de usar una computed property:

 <button class="btn btn-primary">
    <i 
      class="fa fa-2x"
      :class="icon"></i>
  </button>
</template>

<script>

export default {
  props:{
    icon:{
      type: String,
      default: "fa-plus"
    }
  }
}

Ojo,solo puede haber un v-bind a class por elemento.Interesante.

    VIDEO 164 INSTALAR VUEX + MODULO REUTILIZABLE

Usualmente usare Vuex(el store) en base a módulos.Lo primero es instalar la libreria:
>yarn add vuex@next -S

Ahora si,creamos una carpeta store(src/store) para el store global de la aplicación(por ejemplo ui,providers globales,etc).Despues creo otra carpeta store por cada modulo(src/auth/store y src/daybook/store).Cada uno de ellos tendrá el store de ese modulo 
NOTA: un módulo puede incluso a ser lo suficientemente grande como para crearle submodulos o varios stores.No es muy normal esto,realmente.

En este punto vamos a crear un módulo cascarón reutilizable.En este modulo/carpeta creo 5 files,el actions.js para las acciones asincronas,el mutations.js,el getters.js y el state.js.En el quinto file index.js lo usamos como barrel file y para juntar todo:

En el index.js:
import state from './state';
import * as actions from './actions';
import * as getters from './getters';
import * as mutations from './mutations';

const myCustomModule = {
  namespaced:true,
  actions,
  getters,
  mutations,
  state
}

export default myCustomModule;

Este modulo simplemente tendría que cambiar el naming de funciones,etc según modulo a aplicar.Es algo que haremos ya.

  VIDEO 165 MODULO VUEX-MODULE  USANDO MODULO REUTILIZABLE

 Recuerda que vamos a usar stores modularizados.Esto cambia un poquito de usar uno solo,ya que tengo que usar una propiedad modules en el createStore:

 en el src/store/index.js (me traigo todos los stores por modulo)
 const store = createStore({
  modules: {
    a: moduleA,
    b:moduleB
  }
 })
 
 * Obviamente este store es el que le paso al main.js(actually we can only use one store,obviously).
 app.use(store).use(xxx)

 Y cada moduleA será el exp default de cada store/{module}/index.js.Muy interesante,asinto

En nuestra app el src/store/index.js quedaría asi:
import journalModule from '../modules/daybook/store/journal';

const store = createStore({
modules:{
  journal: journalModule
}
})

export default store

TIP: el store tendrá que ir antes de las rutas,logicamente
createApp(App).use(store).use(router).mount("#app");
Desde luego es muy fácil crear un Store modularizado en Vue.Muy interesante la estructura que usó Fernando.

Por último nos creamos ya varias acciones,getters y mutations.Recuerda que las acciones serán acciones asincronas que tendrán impacto en la base de datos,los getters son acciones sincronas para acceder a una parte del store(por ejemplo acceder con una ordenación,con un filtro,etc) y que las mutations son acciones sincronas que acompañaran a las actions

      VIDEO 166 ENTRADAS FICTICIAS Y PUNTO DE RESTAURACIÓN

En el archivo con el state inicial del modulo journal creamos unos valores por defecto:

* En el src/modules/daybook/store/state.js *
export default () => ({
  isLoading: true,
  entries: [
    {
      id: new Date().getTime(), // timestamp numérico
      date: new Date().toDateString(), // sat 23, july
      text: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Dolores voluptate minima commodi tenetur adipisci minus iste. Blanditiis nulla sunt aut recusandae, rem quis asperiores incidunt ad at eligendi possimus! Corrupti?",
      picture: null,
    },
    {
      id: new Date().getTime() + 1000, // timestamp numérico incrementado por si acaso
      date: new Date().toDateString(), // sat 23, july
      text: "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore nemo illo temporibus dignissimos optio. Eum culpa, saepe fugit odit deleniti eveniet perferendis velit? Cumque deleniti enim modi! Nisi, ratione nobis." ,
      picture: null,
    },
    {
      id: new Date().getTime() + 2000, // timestamp numérico incrementado por si acaso
      date: new Date().toDateString(), // sat 23, july
      text: "Lorem ipsum dolor sit amet, sfconsectetur adipisicing sfasfelit. Tempore nemo terribilis prehistorics dignissimos optio. Eum culpa, saepe fugit odit deleniti eveniet perferendis velit? Cumque deleniti enim modi! Nisi, ratione nobis." ,
      picture: null,
    },
  ],
});

